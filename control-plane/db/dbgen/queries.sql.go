// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package dbgen

import (
	"context"
	"database/sql"
	"time"
)

const countFacilities = `-- name: CountFacilities :one
SELECT COUNT(*) as count FROM facilities
`

func (q *Queries) CountFacilities(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countFacilities)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNotifications = `-- name: CountNotifications :one
SELECT COUNT(*) as count FROM notifications
`

func (q *Queries) CountNotifications(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNotifications)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNotificationsByStatus = `-- name: CountNotificationsByStatus :many
SELECT status, COUNT(*) as count FROM notifications GROUP BY status
`

type CountNotificationsByStatusRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

func (q *Queries) CountNotificationsByStatus(ctx context.Context) ([]CountNotificationsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, countNotificationsByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountNotificationsByStatusRow{}
	for rows.Next() {
		var i CountNotificationsByStatusRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countNotificationsToday = `-- name: CountNotificationsToday :one
SELECT COUNT(*) as count FROM notifications WHERE date(created_at) = date('now')
`

func (q *Queries) CountNotificationsToday(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNotificationsToday)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countScrapeJobsByStatus = `-- name: CountScrapeJobsByStatus :many
SELECT status, COUNT(*) as count FROM scrape_jobs WHERE created_at > datetime('now', '-24 hours') GROUP BY status
`

type CountScrapeJobsByStatusRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

func (q *Queries) CountScrapeJobsByStatus(ctx context.Context) ([]CountScrapeJobsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, countScrapeJobsByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountScrapeJobsByStatusRow{}
	for rows.Next() {
		var i CountScrapeJobsByStatusRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countSlots = `-- name: CountSlots :one
SELECT COUNT(*) as count FROM slots
`

func (q *Queries) CountSlots(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSlots)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSlotsByMunicipality = `-- name: CountSlotsByMunicipality :many
SELECT municipality_id, COUNT(*) as count FROM slots WHERE slot_date >= date('now') GROUP BY municipality_id
`

type CountSlotsByMunicipalityRow struct {
	MunicipalityID sql.NullString `json:"municipality_id"`
	Count          int64          `json:"count"`
}

func (q *Queries) CountSlotsByMunicipality(ctx context.Context) ([]CountSlotsByMunicipalityRow, error) {
	rows, err := q.db.QueryContext(ctx, countSlotsByMunicipality)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountSlotsByMunicipalityRow{}
	for rows.Next() {
		var i CountSlotsByMunicipalityRow
		if err := rows.Scan(&i.MunicipalityID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countSupportTickets = `-- name: CountSupportTickets :one
SELECT COUNT(*) as count FROM support_tickets
`

func (q *Queries) CountSupportTickets(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSupportTickets)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSupportTicketsByStatus = `-- name: CountSupportTicketsByStatus :many
SELECT status, COUNT(*) as count FROM support_tickets GROUP BY status
`

type CountSupportTicketsByStatusRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

func (q *Queries) CountSupportTicketsByStatus(ctx context.Context) ([]CountSupportTicketsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, countSupportTicketsByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountSupportTicketsByStatusRow{}
	for rows.Next() {
		var i CountSupportTicketsByStatusRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countTeams = `-- name: CountTeams :one
SELECT COUNT(*) as count FROM teams
`

func (q *Queries) CountTeams(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTeams)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTeamsByPlan = `-- name: CountTeamsByPlan :many
SELECT plan, COUNT(*) as count FROM teams GROUP BY plan
`

type CountTeamsByPlanRow struct {
	Plan  string `json:"plan"`
	Count int64  `json:"count"`
}

func (q *Queries) CountTeamsByPlan(ctx context.Context) ([]CountTeamsByPlanRow, error) {
	rows, err := q.db.QueryContext(ctx, countTeamsByPlan)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountTeamsByPlanRow{}
	for rows.Next() {
		var i CountTeamsByPlanRow
		if err := rows.Scan(&i.Plan, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countVisitors = `-- name: CountVisitors :one
SELECT COUNT(*) as count FROM visitors
`

func (q *Queries) CountVisitors(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countVisitors)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWatchConditions = `-- name: CountWatchConditions :one
SELECT COUNT(*) as count FROM watch_conditions
`

func (q *Queries) CountWatchConditions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countWatchConditions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuthToken = `-- name: CreateAuthToken :one

INSERT INTO auth_tokens (id, team_id, token, expires_at, created_at)
VALUES (?1, ?2, ?3, ?4, CURRENT_TIMESTAMP)
RETURNING id, team_id, token, expires_at, used_at, created_at
`

type CreateAuthTokenParams struct {
	ID        string    `json:"id"`
	TeamID    string    `json:"team_id"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
}

// =============================================================================
// Auth Tokens (magic link authentication)
// =============================================================================
func (q *Queries) CreateAuthToken(ctx context.Context, arg CreateAuthTokenParams) (AuthToken, error) {
	row := q.db.QueryRowContext(ctx, createAuthToken,
		arg.ID,
		arg.TeamID,
		arg.Token,
		arg.ExpiresAt,
	)
	var i AuthToken
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.Token,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createFacility = `-- name: CreateFacility :one

INSERT INTO facilities (id, name, municipality, scraper_type, url, enabled, created_at)
VALUES (?1, ?2, ?3, ?4, ?5, 1, CURRENT_TIMESTAMP)
RETURNING id, name, municipality, scraper_type, url, enabled, created_at
`

type CreateFacilityParams struct {
	ID           string `json:"id"`
	Name         string `json:"name"`
	Municipality string `json:"municipality"`
	ScraperType  string `json:"scraper_type"`
	Url          string `json:"url"`
}

// =============================================================================
// Facilities (legacy)
// =============================================================================
func (q *Queries) CreateFacility(ctx context.Context, arg CreateFacilityParams) (Facility, error) {
	row := q.db.QueryRowContext(ctx, createFacility,
		arg.ID,
		arg.Name,
		arg.Municipality,
		arg.ScraperType,
		arg.Url,
	)
	var i Facility
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Municipality,
		&i.ScraperType,
		&i.Url,
		&i.Enabled,
		&i.CreatedAt,
	)
	return i, err
}

const createGround = `-- name: CreateGround :one
INSERT INTO grounds (id, municipality_id, name, court_pattern, enabled, created_at)
VALUES (?1, ?2, ?3, ?4, 1, CURRENT_TIMESTAMP)
RETURNING id, municipality_id, name, court_pattern, enabled, created_at
`

type CreateGroundParams struct {
	ID             string         `json:"id"`
	MunicipalityID string         `json:"municipality_id"`
	Name           string         `json:"name"`
	CourtPattern   sql.NullString `json:"court_pattern"`
}

func (q *Queries) CreateGround(ctx context.Context, arg CreateGroundParams) (Ground, error) {
	row := q.db.QueryRowContext(ctx, createGround,
		arg.ID,
		arg.MunicipalityID,
		arg.Name,
		arg.CourtPattern,
	)
	var i Ground
	err := row.Scan(
		&i.ID,
		&i.MunicipalityID,
		&i.Name,
		&i.CourtPattern,
		&i.Enabled,
		&i.CreatedAt,
	)
	return i, err
}

const createMunicipality = `-- name: CreateMunicipality :one
INSERT INTO municipalities (id, name, scraper_type, url, enabled, created_at)
VALUES (?1, ?2, ?3, ?4, ?5, CURRENT_TIMESTAMP)
RETURNING id, name, scraper_type, url, enabled, created_at
`

type CreateMunicipalityParams struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	ScraperType string `json:"scraper_type"`
	Url         string `json:"url"`
	Enabled     int64  `json:"enabled"`
}

func (q *Queries) CreateMunicipality(ctx context.Context, arg CreateMunicipalityParams) (Municipality, error) {
	row := q.db.QueryRowContext(ctx, createMunicipality,
		arg.ID,
		arg.Name,
		arg.ScraperType,
		arg.Url,
		arg.Enabled,
	)
	var i Municipality
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ScraperType,
		&i.Url,
		&i.Enabled,
		&i.CreatedAt,
	)
	return i, err
}

const createNotification = `-- name: CreateNotification :one

INSERT INTO notifications (id, team_id, watch_condition_id, slot_id, channel, status, created_at)
VALUES (?1, ?2, ?3, ?4, ?5, 'pending', CURRENT_TIMESTAMP)
RETURNING id, team_id, watch_condition_id, slot_id, channel, status, sent_at, created_at
`

type CreateNotificationParams struct {
	ID               string `json:"id"`
	TeamID           string `json:"team_id"`
	WatchConditionID string `json:"watch_condition_id"`
	SlotID           string `json:"slot_id"`
	Channel          string `json:"channel"`
}

// =============================================================================
// Notifications
// =============================================================================
func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, createNotification,
		arg.ID,
		arg.TeamID,
		arg.WatchConditionID,
		arg.SlotID,
		arg.Channel,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.WatchConditionID,
		&i.SlotID,
		&i.Channel,
		&i.Status,
		&i.SentAt,
		&i.CreatedAt,
	)
	return i, err
}

const createScrapeJob = `-- name: CreateScrapeJob :one

INSERT INTO scrape_jobs (id, municipality_id, status, created_at)
VALUES (?1, ?2, 'pending', CURRENT_TIMESTAMP)
RETURNING id, municipality_id, status, slots_found, error_message, scrape_status, diagnostics, started_at, completed_at, created_at
`

type CreateScrapeJobParams struct {
	ID             string `json:"id"`
	MunicipalityID string `json:"municipality_id"`
}

// =============================================================================
// Scrape Jobs
// =============================================================================
func (q *Queries) CreateScrapeJob(ctx context.Context, arg CreateScrapeJobParams) (ScrapeJob, error) {
	row := q.db.QueryRowContext(ctx, createScrapeJob, arg.ID, arg.MunicipalityID)
	var i ScrapeJob
	err := row.Scan(
		&i.ID,
		&i.MunicipalityID,
		&i.Status,
		&i.SlotsFound,
		&i.ErrorMessage,
		&i.ScrapeStatus,
		&i.Diagnostics,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createSupportMessage = `-- name: CreateSupportMessage :one

INSERT INTO support_messages (id, ticket_id, role, content, created_at)
VALUES (?1, ?2, ?3, ?4, CURRENT_TIMESTAMP)
RETURNING id, ticket_id, role, content, created_at
`

type CreateSupportMessageParams struct {
	ID       string `json:"id"`
	TicketID string `json:"ticket_id"`
	Role     string `json:"role"`
	Content  string `json:"content"`
}

// =============================================================================
// Support Messages
// =============================================================================
func (q *Queries) CreateSupportMessage(ctx context.Context, arg CreateSupportMessageParams) (SupportMessage, error) {
	row := q.db.QueryRowContext(ctx, createSupportMessage,
		arg.ID,
		arg.TicketID,
		arg.Role,
		arg.Content,
	)
	var i SupportMessage
	err := row.Scan(
		&i.ID,
		&i.TicketID,
		&i.Role,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const createSupportTicket = `-- name: CreateSupportTicket :one

INSERT INTO support_tickets (id, team_id, email, subject, status, priority, created_at, updated_at)
VALUES (?1, ?2, ?3, ?4, 'open', 'normal', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
RETURNING id, team_id, email, subject, status, priority, ai_response, human_response, created_at, updated_at
`

type CreateSupportTicketParams struct {
	ID      string         `json:"id"`
	TeamID  sql.NullString `json:"team_id"`
	Email   string         `json:"email"`
	Subject string         `json:"subject"`
}

// =============================================================================
// Support Tickets
// =============================================================================
func (q *Queries) CreateSupportTicket(ctx context.Context, arg CreateSupportTicketParams) (SupportTicket, error) {
	row := q.db.QueryRowContext(ctx, createSupportTicket,
		arg.ID,
		arg.TeamID,
		arg.Email,
		arg.Subject,
	)
	var i SupportTicket
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.Email,
		&i.Subject,
		&i.Status,
		&i.Priority,
		&i.AiResponse,
		&i.HumanResponse,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTeam = `-- name: CreateTeam :one

INSERT INTO teams (id, name, email, plan, status, created_at, updated_at)
VALUES (?1, ?2, ?3, ?4, 'active', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
RETURNING id, name, email, "plan", status, created_at, updated_at
`

type CreateTeamParams struct {
	ID    string `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
	Plan  string `json:"plan"`
}

// =============================================================================
// Teams
// =============================================================================
func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (Team, error) {
	row := q.db.QueryRowContext(ctx, createTeam,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Plan,
	)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Plan,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWatchCondition = `-- name: CreateWatchCondition :one

INSERT INTO watch_conditions (id, team_id, facility_id, days_of_week, time_from, time_to, date_from, date_to, enabled, created_at, updated_at)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, 1, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
RETURNING id, team_id, facility_id, days_of_week, time_from, time_to, date_from, date_to, enabled, created_at, updated_at
`

type CreateWatchConditionParams struct {
	ID         string       `json:"id"`
	TeamID     string       `json:"team_id"`
	FacilityID string       `json:"facility_id"`
	DaysOfWeek string       `json:"days_of_week"`
	TimeFrom   string       `json:"time_from"`
	TimeTo     string       `json:"time_to"`
	DateFrom   sql.NullTime `json:"date_from"`
	DateTo     sql.NullTime `json:"date_to"`
}

// =============================================================================
// Watch Conditions
// =============================================================================
func (q *Queries) CreateWatchCondition(ctx context.Context, arg CreateWatchConditionParams) (WatchCondition, error) {
	row := q.db.QueryRowContext(ctx, createWatchCondition,
		arg.ID,
		arg.TeamID,
		arg.FacilityID,
		arg.DaysOfWeek,
		arg.TimeFrom,
		arg.TimeTo,
		arg.DateFrom,
		arg.DateTo,
	)
	var i WatchCondition
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.FacilityID,
		&i.DaysOfWeek,
		&i.TimeFrom,
		&i.TimeTo,
		&i.DateFrom,
		&i.DateTo,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteExpiredAuthTokens = `-- name: DeleteExpiredAuthTokens :exec
DELETE FROM auth_tokens WHERE expires_at < CURRENT_TIMESTAMP
`

func (q *Queries) DeleteExpiredAuthTokens(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredAuthTokens)
	return err
}

const deleteFacility = `-- name: DeleteFacility :exec
DELETE FROM facilities WHERE id = ?
`

func (q *Queries) DeleteFacility(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteFacility, id)
	return err
}

const deleteOldSlots = `-- name: DeleteOldSlots :exec
DELETE FROM slots WHERE slot_date < date('now', '-7 days')
`

func (q *Queries) DeleteOldSlots(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteOldSlots)
	return err
}

const deleteTeam = `-- name: DeleteTeam :exec
DELETE FROM teams WHERE id = ?
`

func (q *Queries) DeleteTeam(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTeam, id)
	return err
}

const deleteWatchCondition = `-- name: DeleteWatchCondition :exec
DELETE FROM watch_conditions WHERE id = ?
`

func (q *Queries) DeleteWatchCondition(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteWatchCondition, id)
	return err
}

const getAuthTokenByToken = `-- name: GetAuthTokenByToken :one
SELECT at.id, at.team_id, at.token, at.expires_at, at.used_at, at.created_at, t.email as team_email, t.name as team_name
FROM auth_tokens at
JOIN teams t ON at.team_id = t.id
WHERE at.token = ? AND at.used_at IS NULL AND at.expires_at > CURRENT_TIMESTAMP
`

type GetAuthTokenByTokenRow struct {
	ID        string       `json:"id"`
	TeamID    string       `json:"team_id"`
	Token     string       `json:"token"`
	ExpiresAt time.Time    `json:"expires_at"`
	UsedAt    sql.NullTime `json:"used_at"`
	CreatedAt time.Time    `json:"created_at"`
	TeamEmail string       `json:"team_email"`
	TeamName  string       `json:"team_name"`
}

func (q *Queries) GetAuthTokenByToken(ctx context.Context, token string) (GetAuthTokenByTokenRow, error) {
	row := q.db.QueryRowContext(ctx, getAuthTokenByToken, token)
	var i GetAuthTokenByTokenRow
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.Token,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
		&i.TeamEmail,
		&i.TeamName,
	)
	return i, err
}

const getFacility = `-- name: GetFacility :one
SELECT id, name, municipality, scraper_type, url, enabled, created_at FROM facilities WHERE id = ?
`

func (q *Queries) GetFacility(ctx context.Context, id string) (Facility, error) {
	row := q.db.QueryRowContext(ctx, getFacility, id)
	var i Facility
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Municipality,
		&i.ScraperType,
		&i.Url,
		&i.Enabled,
		&i.CreatedAt,
	)
	return i, err
}

const getGround = `-- name: GetGround :one
SELECT g.id, g.municipality_id, g.name, g.court_pattern, g.enabled, g.created_at,
       m.name as municipality_name, m.scraper_type
FROM grounds g
JOIN municipalities m ON g.municipality_id = m.id
WHERE g.id = ?
`

type GetGroundRow struct {
	ID               string         `json:"id"`
	MunicipalityID   string         `json:"municipality_id"`
	Name             string         `json:"name"`
	CourtPattern     sql.NullString `json:"court_pattern"`
	Enabled          int64          `json:"enabled"`
	CreatedAt        time.Time      `json:"created_at"`
	MunicipalityName string         `json:"municipality_name"`
	ScraperType      string         `json:"scraper_type"`
}

func (q *Queries) GetGround(ctx context.Context, id string) (GetGroundRow, error) {
	row := q.db.QueryRowContext(ctx, getGround, id)
	var i GetGroundRow
	err := row.Scan(
		&i.ID,
		&i.MunicipalityID,
		&i.Name,
		&i.CourtPattern,
		&i.Enabled,
		&i.CreatedAt,
		&i.MunicipalityName,
		&i.ScraperType,
	)
	return i, err
}

const getLatestMetric = `-- name: GetLatestMetric :one
SELECT id, metric_name, metric_value, recorded_at FROM system_metrics WHERE metric_name = ? ORDER BY recorded_at DESC LIMIT 1
`

func (q *Queries) GetLatestMetric(ctx context.Context, metricName string) (SystemMetric, error) {
	row := q.db.QueryRowContext(ctx, getLatestMetric, metricName)
	var i SystemMetric
	err := row.Scan(
		&i.ID,
		&i.MetricName,
		&i.MetricValue,
		&i.RecordedAt,
	)
	return i, err
}

const getMetricsHistory = `-- name: GetMetricsHistory :many
SELECT id, metric_name, metric_value, recorded_at FROM system_metrics WHERE metric_name = ? AND recorded_at > datetime('now', ?) ORDER BY recorded_at ASC
`

type GetMetricsHistoryParams struct {
	MetricName string      `json:"metric_name"`
	Datetime   interface{} `json:"datetime"`
}

func (q *Queries) GetMetricsHistory(ctx context.Context, arg GetMetricsHistoryParams) ([]SystemMetric, error) {
	rows, err := q.db.QueryContext(ctx, getMetricsHistory, arg.MetricName, arg.Datetime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SystemMetric{}
	for rows.Next() {
		var i SystemMetric
		if err := rows.Scan(
			&i.ID,
			&i.MetricName,
			&i.MetricValue,
			&i.RecordedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMunicipality = `-- name: GetMunicipality :one
SELECT id, name, scraper_type, url, enabled, created_at FROM municipalities WHERE id = ?
`

func (q *Queries) GetMunicipality(ctx context.Context, id string) (Municipality, error) {
	row := q.db.QueryRowContext(ctx, getMunicipality, id)
	var i Municipality
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ScraperType,
		&i.Url,
		&i.Enabled,
		&i.CreatedAt,
	)
	return i, err
}

const getMunicipalityByScraperType = `-- name: GetMunicipalityByScraperType :one
SELECT id, name, scraper_type, url, enabled, created_at FROM municipalities WHERE scraper_type = ?
`

func (q *Queries) GetMunicipalityByScraperType(ctx context.Context, scraperType string) (Municipality, error) {
	row := q.db.QueryRowContext(ctx, getMunicipalityByScraperType, scraperType)
	var i Municipality
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ScraperType,
		&i.Url,
		&i.Enabled,
		&i.CreatedAt,
	)
	return i, err
}

const getNotification = `-- name: GetNotification :one
SELECT id, team_id, watch_condition_id, slot_id, channel, status, sent_at, created_at FROM notifications WHERE id = ?
`

func (q *Queries) GetNotification(ctx context.Context, id string) (Notification, error) {
	row := q.db.QueryRowContext(ctx, getNotification, id)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.WatchConditionID,
		&i.SlotID,
		&i.Channel,
		&i.Status,
		&i.SentAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPlanLimits = `-- name: GetPlanLimits :one

SELECT "plan", max_grounds, weekend_only, max_conditions_per_ground, notification_priority FROM plan_limits WHERE plan = ?
`

// =============================================================================
// Plan Limits
// =============================================================================
func (q *Queries) GetPlanLimits(ctx context.Context, plan string) (PlanLimit, error) {
	row := q.db.QueryRowContext(ctx, getPlanLimits, plan)
	var i PlanLimit
	err := row.Scan(
		&i.Plan,
		&i.MaxGrounds,
		&i.WeekendOnly,
		&i.MaxConditionsPerGround,
		&i.NotificationPriority,
	)
	return i, err
}

const getScrapeJob = `-- name: GetScrapeJob :one
SELECT id, municipality_id, status, slots_found, error_message, scrape_status, diagnostics, started_at, completed_at, created_at FROM scrape_jobs WHERE id = ?
`

func (q *Queries) GetScrapeJob(ctx context.Context, id string) (ScrapeJob, error) {
	row := q.db.QueryRowContext(ctx, getScrapeJob, id)
	var i ScrapeJob
	err := row.Scan(
		&i.ID,
		&i.MunicipalityID,
		&i.Status,
		&i.SlotsFound,
		&i.ErrorMessage,
		&i.ScrapeStatus,
		&i.Diagnostics,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSlot = `-- name: GetSlot :one
SELECT id, facility_id, municipality_id, ground_id, slot_date, time_from, time_to, court_name, raw_text, scraped_at FROM slots WHERE id = ?
`

func (q *Queries) GetSlot(ctx context.Context, id string) (Slot, error) {
	row := q.db.QueryRowContext(ctx, getSlot, id)
	var i Slot
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.MunicipalityID,
		&i.GroundID,
		&i.SlotDate,
		&i.TimeFrom,
		&i.TimeTo,
		&i.CourtName,
		&i.RawText,
		&i.ScrapedAt,
	)
	return i, err
}

const getSupportTicket = `-- name: GetSupportTicket :one
SELECT id, team_id, email, subject, status, priority, ai_response, human_response, created_at, updated_at FROM support_tickets WHERE id = ?
`

func (q *Queries) GetSupportTicket(ctx context.Context, id string) (SupportTicket, error) {
	row := q.db.QueryRowContext(ctx, getSupportTicket, id)
	var i SupportTicket
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.Email,
		&i.Subject,
		&i.Status,
		&i.Priority,
		&i.AiResponse,
		&i.HumanResponse,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTeam = `-- name: GetTeam :one
SELECT id, name, email, "plan", status, created_at, updated_at FROM teams WHERE id = ?
`

func (q *Queries) GetTeam(ctx context.Context, id string) (Team, error) {
	row := q.db.QueryRowContext(ctx, getTeam, id)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Plan,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTeamByEmail = `-- name: GetTeamByEmail :one
SELECT id, name, email, "plan", status, created_at, updated_at FROM teams WHERE email = ?
`

func (q *Queries) GetTeamByEmail(ctx context.Context, email string) (Team, error) {
	row := q.db.QueryRowContext(ctx, getTeamByEmail, email)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Plan,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVisitor = `-- name: GetVisitor :one
SELECT id, view_count, created_at, last_seen FROM visitors WHERE id = ?
`

func (q *Queries) GetVisitor(ctx context.Context, id string) (Visitor, error) {
	row := q.db.QueryRowContext(ctx, getVisitor, id)
	var i Visitor
	err := row.Scan(
		&i.ID,
		&i.ViewCount,
		&i.CreatedAt,
		&i.LastSeen,
	)
	return i, err
}

const getWatchCondition = `-- name: GetWatchCondition :one
SELECT id, team_id, facility_id, days_of_week, time_from, time_to, date_from, date_to, enabled, created_at, updated_at FROM watch_conditions WHERE id = ?
`

func (q *Queries) GetWatchCondition(ctx context.Context, id string) (WatchCondition, error) {
	row := q.db.QueryRowContext(ctx, getWatchCondition, id)
	var i WatchCondition
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.FacilityID,
		&i.DaysOfWeek,
		&i.TimeFrom,
		&i.TimeTo,
		&i.DateFrom,
		&i.DateTo,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllMunicipalities = `-- name: ListAllMunicipalities :many
SELECT id, name, scraper_type, url, enabled, created_at FROM municipalities ORDER BY name
`

func (q *Queries) ListAllMunicipalities(ctx context.Context) ([]Municipality, error) {
	rows, err := q.db.QueryContext(ctx, listAllMunicipalities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Municipality{}
	for rows.Next() {
		var i Municipality
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ScraperType,
			&i.Url,
			&i.Enabled,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnabledFacilities = `-- name: ListEnabledFacilities :many
SELECT id, name, municipality, scraper_type, url, enabled, created_at FROM facilities WHERE enabled = 1 ORDER BY municipality, name
`

func (q *Queries) ListEnabledFacilities(ctx context.Context) ([]Facility, error) {
	rows, err := q.db.QueryContext(ctx, listEnabledFacilities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Facility{}
	for rows.Next() {
		var i Facility
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Municipality,
			&i.ScraperType,
			&i.Url,
			&i.Enabled,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFacilities = `-- name: ListFacilities :many
SELECT id, name, municipality, scraper_type, url, enabled, created_at FROM facilities ORDER BY municipality, name LIMIT ? OFFSET ?
`

type ListFacilitiesParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListFacilities(ctx context.Context, arg ListFacilitiesParams) ([]Facility, error) {
	rows, err := q.db.QueryContext(ctx, listFacilities, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Facility{}
	for rows.Next() {
		var i Facility
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Municipality,
			&i.ScraperType,
			&i.Url,
			&i.Enabled,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGrounds = `-- name: ListGrounds :many

SELECT g.id, g.municipality_id, g.name, g.court_pattern, g.enabled, g.created_at,
       m.name as municipality_name, m.scraper_type
FROM grounds g
JOIN municipalities m ON g.municipality_id = m.id
WHERE g.enabled = 1
ORDER BY m.name, g.name
`

type ListGroundsRow struct {
	ID               string         `json:"id"`
	MunicipalityID   string         `json:"municipality_id"`
	Name             string         `json:"name"`
	CourtPattern     sql.NullString `json:"court_pattern"`
	Enabled          int64          `json:"enabled"`
	CreatedAt        time.Time      `json:"created_at"`
	MunicipalityName string         `json:"municipality_name"`
	ScraperType      string         `json:"scraper_type"`
}

// =============================================================================
// Grounds (grounds)
// =============================================================================
func (q *Queries) ListGrounds(ctx context.Context) ([]ListGroundsRow, error) {
	rows, err := q.db.QueryContext(ctx, listGrounds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGroundsRow{}
	for rows.Next() {
		var i ListGroundsRow
		if err := rows.Scan(
			&i.ID,
			&i.MunicipalityID,
			&i.Name,
			&i.CourtPattern,
			&i.Enabled,
			&i.CreatedAt,
			&i.MunicipalityName,
			&i.ScraperType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroundsByMunicipality = `-- name: ListGroundsByMunicipality :many
SELECT id, municipality_id, name, court_pattern, enabled, created_at FROM grounds WHERE municipality_id = ? AND enabled = 1 ORDER BY name
`

func (q *Queries) ListGroundsByMunicipality(ctx context.Context, municipalityID string) ([]Ground, error) {
	rows, err := q.db.QueryContext(ctx, listGroundsByMunicipality, municipalityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ground{}
	for rows.Next() {
		var i Ground
		if err := rows.Scan(
			&i.ID,
			&i.MunicipalityID,
			&i.Name,
			&i.CourtPattern,
			&i.Enabled,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMunicipalities = `-- name: ListMunicipalities :many

SELECT id, name, scraper_type, url, enabled, created_at FROM municipalities WHERE enabled = 1 ORDER BY name
`

// =============================================================================
// Municipalities (municipalities)
// =============================================================================
func (q *Queries) ListMunicipalities(ctx context.Context) ([]Municipality, error) {
	rows, err := q.db.QueryContext(ctx, listMunicipalities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Municipality{}
	for rows.Next() {
		var i Municipality
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ScraperType,
			&i.Url,
			&i.Enabled,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotificationsByTeam = `-- name: ListNotificationsByTeam :many
SELECT id, team_id, watch_condition_id, slot_id, channel, status, sent_at, created_at FROM notifications WHERE team_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListNotificationsByTeamParams struct {
	TeamID string `json:"team_id"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) ListNotificationsByTeam(ctx context.Context, arg ListNotificationsByTeamParams) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, listNotificationsByTeam, arg.TeamID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.WatchConditionID,
			&i.SlotID,
			&i.Channel,
			&i.Status,
			&i.SentAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOpenSupportTickets = `-- name: ListOpenSupportTickets :many
SELECT id, team_id, email, subject, status, priority, ai_response, human_response, created_at, updated_at FROM support_tickets WHERE status IN ('open', 'escalated') ORDER BY
    CASE priority WHEN 'urgent' THEN 1 WHEN 'high' THEN 2 WHEN 'normal' THEN 3 ELSE 4 END,
    created_at DESC
`

func (q *Queries) ListOpenSupportTickets(ctx context.Context) ([]SupportTicket, error) {
	rows, err := q.db.QueryContext(ctx, listOpenSupportTickets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SupportTicket{}
	for rows.Next() {
		var i SupportTicket
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.Email,
			&i.Subject,
			&i.Status,
			&i.Priority,
			&i.AiResponse,
			&i.HumanResponse,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentScrapeJobs = `-- name: ListRecentScrapeJobs :many
SELECT sj.id, sj.municipality_id, sj.status, sj.slots_found, sj.error_message, sj.scrape_status, sj.diagnostics, sj.started_at, sj.completed_at, sj.created_at, m.name as municipality_name, m.scraper_type
FROM scrape_jobs sj
JOIN municipalities m ON sj.municipality_id = m.id
ORDER BY sj.created_at DESC LIMIT ?
`

type ListRecentScrapeJobsRow struct {
	ID               string         `json:"id"`
	MunicipalityID   string         `json:"municipality_id"`
	Status           string         `json:"status"`
	SlotsFound       sql.NullInt64  `json:"slots_found"`
	ErrorMessage     sql.NullString `json:"error_message"`
	ScrapeStatus     sql.NullString `json:"scrape_status"`
	Diagnostics      sql.NullString `json:"diagnostics"`
	StartedAt        sql.NullTime   `json:"started_at"`
	CompletedAt      sql.NullTime   `json:"completed_at"`
	CreatedAt        time.Time      `json:"created_at"`
	MunicipalityName string         `json:"municipality_name"`
	ScraperType      string         `json:"scraper_type"`
}

func (q *Queries) ListRecentScrapeJobs(ctx context.Context, limit int64) ([]ListRecentScrapeJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, listRecentScrapeJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecentScrapeJobsRow{}
	for rows.Next() {
		var i ListRecentScrapeJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.MunicipalityID,
			&i.Status,
			&i.SlotsFound,
			&i.ErrorMessage,
			&i.ScrapeStatus,
			&i.Diagnostics,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.MunicipalityName,
			&i.ScraperType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSlotsByDateRange = `-- name: ListSlotsByDateRange :many
SELECT id, facility_id, municipality_id, ground_id, slot_date, time_from, time_to, court_name, raw_text, scraped_at FROM slots WHERE municipality_id = ? AND slot_date BETWEEN ? AND ? ORDER BY slot_date, time_from
`

func (q *Queries) ListSlotsByDateRange(ctx context.Context, municipalityID sql.NullString) ([]Slot, error) {
	rows, err := q.db.QueryContext(ctx, listSlotsByDateRange, municipalityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Slot{}
	for rows.Next() {
		var i Slot
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.MunicipalityID,
			&i.GroundID,
			&i.SlotDate,
			&i.TimeFrom,
			&i.TimeTo,
			&i.CourtName,
			&i.RawText,
			&i.ScrapedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSlotsByFacility = `-- name: ListSlotsByFacility :many
SELECT id, facility_id, municipality_id, ground_id, slot_date, time_from, time_to, court_name, raw_text, scraped_at FROM slots WHERE facility_id = ? AND slot_date >= date('now') ORDER BY slot_date, time_from
`

func (q *Queries) ListSlotsByFacility(ctx context.Context, facilityID sql.NullString) ([]Slot, error) {
	rows, err := q.db.QueryContext(ctx, listSlotsByFacility, facilityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Slot{}
	for rows.Next() {
		var i Slot
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.MunicipalityID,
			&i.GroundID,
			&i.SlotDate,
			&i.TimeFrom,
			&i.TimeTo,
			&i.CourtName,
			&i.RawText,
			&i.ScrapedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSlotsByGround = `-- name: ListSlotsByGround :many
SELECT id, facility_id, municipality_id, ground_id, slot_date, time_from, time_to, court_name, raw_text, scraped_at FROM slots WHERE ground_id = ? AND slot_date >= date('now') ORDER BY slot_date, time_from
`

func (q *Queries) ListSlotsByGround(ctx context.Context, groundID sql.NullString) ([]Slot, error) {
	rows, err := q.db.QueryContext(ctx, listSlotsByGround, groundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Slot{}
	for rows.Next() {
		var i Slot
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.MunicipalityID,
			&i.GroundID,
			&i.SlotDate,
			&i.TimeFrom,
			&i.TimeTo,
			&i.CourtName,
			&i.RawText,
			&i.ScrapedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSlotsByMunicipality = `-- name: ListSlotsByMunicipality :many
SELECT id, facility_id, municipality_id, ground_id, slot_date, time_from, time_to, court_name, raw_text, scraped_at FROM slots WHERE municipality_id = ? AND slot_date >= date('now') ORDER BY slot_date, time_from
`

func (q *Queries) ListSlotsByMunicipality(ctx context.Context, municipalityID sql.NullString) ([]Slot, error) {
	rows, err := q.db.QueryContext(ctx, listSlotsByMunicipality, municipalityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Slot{}
	for rows.Next() {
		var i Slot
		if err := rows.Scan(
			&i.ID,
			&i.FacilityID,
			&i.MunicipalityID,
			&i.GroundID,
			&i.SlotDate,
			&i.TimeFrom,
			&i.TimeTo,
			&i.CourtName,
			&i.RawText,
			&i.ScrapedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSupportMessagesByTicket = `-- name: ListSupportMessagesByTicket :many
SELECT id, ticket_id, role, content, created_at FROM support_messages WHERE ticket_id = ? ORDER BY created_at ASC
`

func (q *Queries) ListSupportMessagesByTicket(ctx context.Context, ticketID string) ([]SupportMessage, error) {
	rows, err := q.db.QueryContext(ctx, listSupportMessagesByTicket, ticketID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SupportMessage{}
	for rows.Next() {
		var i SupportMessage
		if err := rows.Scan(
			&i.ID,
			&i.TicketID,
			&i.Role,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSupportTickets = `-- name: ListSupportTickets :many
SELECT id, team_id, email, subject, status, priority, ai_response, human_response, created_at, updated_at FROM support_tickets ORDER BY
    CASE priority WHEN 'urgent' THEN 1 WHEN 'high' THEN 2 WHEN 'normal' THEN 3 ELSE 4 END,
    created_at DESC
LIMIT ? OFFSET ?
`

type ListSupportTicketsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListSupportTickets(ctx context.Context, arg ListSupportTicketsParams) ([]SupportTicket, error) {
	rows, err := q.db.QueryContext(ctx, listSupportTickets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SupportTicket{}
	for rows.Next() {
		var i SupportTicket
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.Email,
			&i.Subject,
			&i.Status,
			&i.Priority,
			&i.AiResponse,
			&i.HumanResponse,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeams = `-- name: ListTeams :many
SELECT id, name, email, "plan", status, created_at, updated_at FROM teams ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListTeamsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListTeams(ctx context.Context, arg ListTeamsParams) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, listTeams, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Plan,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWatchConditionsByFacility = `-- name: ListWatchConditionsByFacility :many
SELECT wc.id, wc.team_id, wc.facility_id, wc.days_of_week, wc.time_from, wc.time_to, wc.date_from, wc.date_to, wc.enabled, wc.created_at, wc.updated_at, t.email as team_email, t.name as team_name
FROM watch_conditions wc
JOIN teams t ON wc.team_id = t.id
WHERE wc.facility_id = ? AND wc.enabled = 1 AND t.status = 'active'
`

type ListWatchConditionsByFacilityRow struct {
	ID         string       `json:"id"`
	TeamID     string       `json:"team_id"`
	FacilityID string       `json:"facility_id"`
	DaysOfWeek string       `json:"days_of_week"`
	TimeFrom   string       `json:"time_from"`
	TimeTo     string       `json:"time_to"`
	DateFrom   sql.NullTime `json:"date_from"`
	DateTo     sql.NullTime `json:"date_to"`
	Enabled    int64        `json:"enabled"`
	CreatedAt  time.Time    `json:"created_at"`
	UpdatedAt  time.Time    `json:"updated_at"`
	TeamEmail  string       `json:"team_email"`
	TeamName   string       `json:"team_name"`
}

func (q *Queries) ListWatchConditionsByFacility(ctx context.Context, facilityID string) ([]ListWatchConditionsByFacilityRow, error) {
	rows, err := q.db.QueryContext(ctx, listWatchConditionsByFacility, facilityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWatchConditionsByFacilityRow{}
	for rows.Next() {
		var i ListWatchConditionsByFacilityRow
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.FacilityID,
			&i.DaysOfWeek,
			&i.TimeFrom,
			&i.TimeTo,
			&i.DateFrom,
			&i.DateTo,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TeamEmail,
			&i.TeamName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWatchConditionsByTeam = `-- name: ListWatchConditionsByTeam :many
SELECT id, team_id, facility_id, days_of_week, time_from, time_to, date_from, date_to, enabled, created_at, updated_at FROM watch_conditions WHERE team_id = ? ORDER BY created_at DESC
`

func (q *Queries) ListWatchConditionsByTeam(ctx context.Context, teamID string) ([]WatchCondition, error) {
	rows, err := q.db.QueryContext(ctx, listWatchConditionsByTeam, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WatchCondition{}
	for rows.Next() {
		var i WatchCondition
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.FacilityID,
			&i.DaysOfWeek,
			&i.TimeFrom,
			&i.TimeTo,
			&i.DateFrom,
			&i.DateTo,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAuthTokenUsed = `-- name: MarkAuthTokenUsed :exec
UPDATE auth_tokens SET used_at = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) MarkAuthTokenUsed(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, markAuthTokenUsed, id)
	return err
}

const matchGroundByCourtName = `-- name: MatchGroundByCourtName :one
SELECT g.id FROM grounds g
WHERE g.municipality_id = ?1 AND instr(?2, g.court_pattern) > 0
LIMIT 1
`

type MatchGroundByCourtNameParams struct {
	MunicipalityID string `json:"municipality_id"`
	INSTR          string `json:"INSTR"`
}

func (q *Queries) MatchGroundByCourtName(ctx context.Context, arg MatchGroundByCourtNameParams) (string, error) {
	row := q.db.QueryRowContext(ctx, matchGroundByCourtName, arg.MunicipalityID, arg.INSTR)
	var id string
	err := row.Scan(&id)
	return id, err
}

const recordMetric = `-- name: RecordMetric :exec

INSERT INTO system_metrics (metric_name, metric_value, recorded_at)
VALUES (?1, ?2, CURRENT_TIMESTAMP)
`

type RecordMetricParams struct {
	MetricName  string  `json:"metric_name"`
	MetricValue float64 `json:"metric_value"`
}

// =============================================================================
// System Metrics
// =============================================================================
func (q *Queries) RecordMetric(ctx context.Context, arg RecordMetricParams) error {
	_, err := q.db.ExecContext(ctx, recordMetric, arg.MetricName, arg.MetricValue)
	return err
}

const updateFacility = `-- name: UpdateFacility :exec
UPDATE facilities SET name = ?2, municipality = ?3, scraper_type = ?4, url = ?5, enabled = ?6 WHERE id = ?1
`

type UpdateFacilityParams struct {
	ID           string `json:"id"`
	Name         string `json:"name"`
	Municipality string `json:"municipality"`
	ScraperType  string `json:"scraper_type"`
	Url          string `json:"url"`
	Enabled      int64  `json:"enabled"`
}

func (q *Queries) UpdateFacility(ctx context.Context, arg UpdateFacilityParams) error {
	_, err := q.db.ExecContext(ctx, updateFacility,
		arg.ID,
		arg.Name,
		arg.Municipality,
		arg.ScraperType,
		arg.Url,
		arg.Enabled,
	)
	return err
}

const updateNotificationStatus = `-- name: UpdateNotificationStatus :exec
UPDATE notifications SET status = ?2, sent_at = CASE WHEN ?2 = 'sent' THEN CURRENT_TIMESTAMP ELSE sent_at END WHERE id = ?1
`

type UpdateNotificationStatusParams struct {
	ID     string `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateNotificationStatus(ctx context.Context, arg UpdateNotificationStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateNotificationStatus, arg.ID, arg.Status)
	return err
}

const updateScrapeJobStatus = `-- name: UpdateScrapeJobStatus :exec
UPDATE scrape_jobs SET
    status = ?2,
    slots_found = ?3,
    error_message = ?4,
    scrape_status = ?5,
    diagnostics = ?6,
    started_at = CASE WHEN ?2 = 'running' THEN CURRENT_TIMESTAMP ELSE started_at END,
    completed_at = CASE WHEN ?2 IN ('completed', 'failed') THEN CURRENT_TIMESTAMP ELSE completed_at END
WHERE id = ?1
`

type UpdateScrapeJobStatusParams struct {
	ID           string         `json:"id"`
	Status       string         `json:"status"`
	SlotsFound   sql.NullInt64  `json:"slots_found"`
	ErrorMessage sql.NullString `json:"error_message"`
	ScrapeStatus sql.NullString `json:"scrape_status"`
	Diagnostics  sql.NullString `json:"diagnostics"`
}

func (q *Queries) UpdateScrapeJobStatus(ctx context.Context, arg UpdateScrapeJobStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateScrapeJobStatus,
		arg.ID,
		arg.Status,
		arg.SlotsFound,
		arg.ErrorMessage,
		arg.ScrapeStatus,
		arg.Diagnostics,
	)
	return err
}

const updateSupportTicket = `-- name: UpdateSupportTicket :exec
UPDATE support_tickets SET status = ?2, priority = ?3, ai_response = ?4, human_response = ?5, updated_at = CURRENT_TIMESTAMP WHERE id = ?1
`

type UpdateSupportTicketParams struct {
	ID            string         `json:"id"`
	Status        string         `json:"status"`
	Priority      string         `json:"priority"`
	AiResponse    sql.NullString `json:"ai_response"`
	HumanResponse sql.NullString `json:"human_response"`
}

func (q *Queries) UpdateSupportTicket(ctx context.Context, arg UpdateSupportTicketParams) error {
	_, err := q.db.ExecContext(ctx, updateSupportTicket,
		arg.ID,
		arg.Status,
		arg.Priority,
		arg.AiResponse,
		arg.HumanResponse,
	)
	return err
}

const updateSupportTicketAIResponse = `-- name: UpdateSupportTicketAIResponse :exec
UPDATE support_tickets SET ai_response = ?2, status = 'ai_handled', updated_at = CURRENT_TIMESTAMP WHERE id = ?1
`

type UpdateSupportTicketAIResponseParams struct {
	ID         string         `json:"id"`
	AiResponse sql.NullString `json:"ai_response"`
}

func (q *Queries) UpdateSupportTicketAIResponse(ctx context.Context, arg UpdateSupportTicketAIResponseParams) error {
	_, err := q.db.ExecContext(ctx, updateSupportTicketAIResponse, arg.ID, arg.AiResponse)
	return err
}

const updateTeam = `-- name: UpdateTeam :exec
UPDATE teams SET name = ?2, email = ?3, plan = ?4, status = ?5, updated_at = CURRENT_TIMESTAMP WHERE id = ?1
`

type UpdateTeamParams struct {
	ID     string `json:"id"`
	Name   string `json:"name"`
	Email  string `json:"email"`
	Plan   string `json:"plan"`
	Status string `json:"status"`
}

func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) error {
	_, err := q.db.ExecContext(ctx, updateTeam,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Plan,
		arg.Status,
	)
	return err
}

const updateWatchCondition = `-- name: UpdateWatchCondition :exec
UPDATE watch_conditions SET facility_id = ?2, days_of_week = ?3, time_from = ?4, time_to = ?5, date_from = ?6, date_to = ?7, enabled = ?8, updated_at = CURRENT_TIMESTAMP WHERE id = ?1
`

type UpdateWatchConditionParams struct {
	ID         string       `json:"id"`
	FacilityID string       `json:"facility_id"`
	DaysOfWeek string       `json:"days_of_week"`
	TimeFrom   string       `json:"time_from"`
	TimeTo     string       `json:"time_to"`
	DateFrom   sql.NullTime `json:"date_from"`
	DateTo     sql.NullTime `json:"date_to"`
	Enabled    int64        `json:"enabled"`
}

func (q *Queries) UpdateWatchCondition(ctx context.Context, arg UpdateWatchConditionParams) error {
	_, err := q.db.ExecContext(ctx, updateWatchCondition,
		arg.ID,
		arg.FacilityID,
		arg.DaysOfWeek,
		arg.TimeFrom,
		arg.TimeTo,
		arg.DateFrom,
		arg.DateTo,
		arg.Enabled,
	)
	return err
}

const upsertSlot = `-- name: UpsertSlot :one

INSERT INTO slots (id, facility_id, municipality_id, ground_id, slot_date, time_from, time_to, court_name, raw_text, scraped_at)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, CURRENT_TIMESTAMP)
ON CONFLICT(municipality_id, slot_date, time_from, time_to, court_name) DO UPDATE SET
    ground_id = COALESCE(excluded.ground_id, slots.ground_id),
    raw_text = excluded.raw_text,
    scraped_at = CURRENT_TIMESTAMP
RETURNING id, facility_id, municipality_id, ground_id, slot_date, time_from, time_to, court_name, raw_text, scraped_at
`

type UpsertSlotParams struct {
	ID             string         `json:"id"`
	FacilityID     sql.NullString `json:"facility_id"`
	MunicipalityID sql.NullString `json:"municipality_id"`
	GroundID       sql.NullString `json:"ground_id"`
	SlotDate       time.Time      `json:"slot_date"`
	TimeFrom       string         `json:"time_from"`
	TimeTo         string         `json:"time_to"`
	CourtName      sql.NullString `json:"court_name"`
	RawText        sql.NullString `json:"raw_text"`
}

// =============================================================================
// Slots
// =============================================================================
func (q *Queries) UpsertSlot(ctx context.Context, arg UpsertSlotParams) (Slot, error) {
	row := q.db.QueryRowContext(ctx, upsertSlot,
		arg.ID,
		arg.FacilityID,
		arg.MunicipalityID,
		arg.GroundID,
		arg.SlotDate,
		arg.TimeFrom,
		arg.TimeTo,
		arg.CourtName,
		arg.RawText,
	)
	var i Slot
	err := row.Scan(
		&i.ID,
		&i.FacilityID,
		&i.MunicipalityID,
		&i.GroundID,
		&i.SlotDate,
		&i.TimeFrom,
		&i.TimeTo,
		&i.CourtName,
		&i.RawText,
		&i.ScrapedAt,
	)
	return i, err
}

const upsertVisitor = `-- name: UpsertVisitor :one

INSERT INTO visitors (id, view_count, created_at, last_seen)
VALUES (?1, 1, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT(id) DO UPDATE SET
    view_count = visitors.view_count + 1,
    last_seen = CURRENT_TIMESTAMP
RETURNING id, view_count, created_at, last_seen
`

// =============================================================================
// Visitors (legacy)
// =============================================================================
func (q *Queries) UpsertVisitor(ctx context.Context, id string) (Visitor, error) {
	row := q.db.QueryRowContext(ctx, upsertVisitor, id)
	var i Visitor
	err := row.Scan(
		&i.ID,
		&i.ViewCount,
		&i.CreatedAt,
		&i.LastSeen,
	)
	return i, err
}
