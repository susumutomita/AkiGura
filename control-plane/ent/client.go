// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"srv.exe.dev/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"srv.exe.dev/ent/authtoken"
	"srv.exe.dev/ent/facility"
	"srv.exe.dev/ent/ground"
	"srv.exe.dev/ent/municipality"
	"srv.exe.dev/ent/notification"
	"srv.exe.dev/ent/promocode"
	"srv.exe.dev/ent/promocodeusage"
	"srv.exe.dev/ent/scrapejob"
	"srv.exe.dev/ent/slot"
	"srv.exe.dev/ent/supportmessage"
	"srv.exe.dev/ent/supportticket"
	"srv.exe.dev/ent/team"
	"srv.exe.dev/ent/watchcondition"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AuthToken is the client for interacting with the AuthToken builders.
	AuthToken *AuthTokenClient
	// Facility is the client for interacting with the Facility builders.
	Facility *FacilityClient
	// Ground is the client for interacting with the Ground builders.
	Ground *GroundClient
	// Municipality is the client for interacting with the Municipality builders.
	Municipality *MunicipalityClient
	// Notification is the client for interacting with the Notification builders.
	Notification *NotificationClient
	// PromoCode is the client for interacting with the PromoCode builders.
	PromoCode *PromoCodeClient
	// PromoCodeUsage is the client for interacting with the PromoCodeUsage builders.
	PromoCodeUsage *PromoCodeUsageClient
	// ScrapeJob is the client for interacting with the ScrapeJob builders.
	ScrapeJob *ScrapeJobClient
	// Slot is the client for interacting with the Slot builders.
	Slot *SlotClient
	// SupportMessage is the client for interacting with the SupportMessage builders.
	SupportMessage *SupportMessageClient
	// SupportTicket is the client for interacting with the SupportTicket builders.
	SupportTicket *SupportTicketClient
	// Team is the client for interacting with the Team builders.
	Team *TeamClient
	// WatchCondition is the client for interacting with the WatchCondition builders.
	WatchCondition *WatchConditionClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AuthToken = NewAuthTokenClient(c.config)
	c.Facility = NewFacilityClient(c.config)
	c.Ground = NewGroundClient(c.config)
	c.Municipality = NewMunicipalityClient(c.config)
	c.Notification = NewNotificationClient(c.config)
	c.PromoCode = NewPromoCodeClient(c.config)
	c.PromoCodeUsage = NewPromoCodeUsageClient(c.config)
	c.ScrapeJob = NewScrapeJobClient(c.config)
	c.Slot = NewSlotClient(c.config)
	c.SupportMessage = NewSupportMessageClient(c.config)
	c.SupportTicket = NewSupportTicketClient(c.config)
	c.Team = NewTeamClient(c.config)
	c.WatchCondition = NewWatchConditionClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:            ctx,
		config:         cfg,
		AuthToken:      NewAuthTokenClient(cfg),
		Facility:       NewFacilityClient(cfg),
		Ground:         NewGroundClient(cfg),
		Municipality:   NewMunicipalityClient(cfg),
		Notification:   NewNotificationClient(cfg),
		PromoCode:      NewPromoCodeClient(cfg),
		PromoCodeUsage: NewPromoCodeUsageClient(cfg),
		ScrapeJob:      NewScrapeJobClient(cfg),
		Slot:           NewSlotClient(cfg),
		SupportMessage: NewSupportMessageClient(cfg),
		SupportTicket:  NewSupportTicketClient(cfg),
		Team:           NewTeamClient(cfg),
		WatchCondition: NewWatchConditionClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:            ctx,
		config:         cfg,
		AuthToken:      NewAuthTokenClient(cfg),
		Facility:       NewFacilityClient(cfg),
		Ground:         NewGroundClient(cfg),
		Municipality:   NewMunicipalityClient(cfg),
		Notification:   NewNotificationClient(cfg),
		PromoCode:      NewPromoCodeClient(cfg),
		PromoCodeUsage: NewPromoCodeUsageClient(cfg),
		ScrapeJob:      NewScrapeJobClient(cfg),
		Slot:           NewSlotClient(cfg),
		SupportMessage: NewSupportMessageClient(cfg),
		SupportTicket:  NewSupportTicketClient(cfg),
		Team:           NewTeamClient(cfg),
		WatchCondition: NewWatchConditionClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AuthToken.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AuthToken, c.Facility, c.Ground, c.Municipality, c.Notification, c.PromoCode,
		c.PromoCodeUsage, c.ScrapeJob, c.Slot, c.SupportMessage, c.SupportTicket,
		c.Team, c.WatchCondition,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AuthToken, c.Facility, c.Ground, c.Municipality, c.Notification, c.PromoCode,
		c.PromoCodeUsage, c.ScrapeJob, c.Slot, c.SupportMessage, c.SupportTicket,
		c.Team, c.WatchCondition,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AuthTokenMutation:
		return c.AuthToken.mutate(ctx, m)
	case *FacilityMutation:
		return c.Facility.mutate(ctx, m)
	case *GroundMutation:
		return c.Ground.mutate(ctx, m)
	case *MunicipalityMutation:
		return c.Municipality.mutate(ctx, m)
	case *NotificationMutation:
		return c.Notification.mutate(ctx, m)
	case *PromoCodeMutation:
		return c.PromoCode.mutate(ctx, m)
	case *PromoCodeUsageMutation:
		return c.PromoCodeUsage.mutate(ctx, m)
	case *ScrapeJobMutation:
		return c.ScrapeJob.mutate(ctx, m)
	case *SlotMutation:
		return c.Slot.mutate(ctx, m)
	case *SupportMessageMutation:
		return c.SupportMessage.mutate(ctx, m)
	case *SupportTicketMutation:
		return c.SupportTicket.mutate(ctx, m)
	case *TeamMutation:
		return c.Team.mutate(ctx, m)
	case *WatchConditionMutation:
		return c.WatchCondition.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AuthTokenClient is a client for the AuthToken schema.
type AuthTokenClient struct {
	config
}

// NewAuthTokenClient returns a client for the AuthToken from the given config.
func NewAuthTokenClient(c config) *AuthTokenClient {
	return &AuthTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authtoken.Hooks(f(g(h())))`.
func (c *AuthTokenClient) Use(hooks ...Hook) {
	c.hooks.AuthToken = append(c.hooks.AuthToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authtoken.Intercept(f(g(h())))`.
func (c *AuthTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthToken = append(c.inters.AuthToken, interceptors...)
}

// Create returns a builder for creating a AuthToken entity.
func (c *AuthTokenClient) Create() *AuthTokenCreate {
	mutation := newAuthTokenMutation(c.config, OpCreate)
	return &AuthTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthToken entities.
func (c *AuthTokenClient) CreateBulk(builders ...*AuthTokenCreate) *AuthTokenCreateBulk {
	return &AuthTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthTokenClient) MapCreateBulk(slice any, setFunc func(*AuthTokenCreate, int)) *AuthTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthTokenCreateBulk{err: fmt.Errorf("calling to AuthTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthToken.
func (c *AuthTokenClient) Update() *AuthTokenUpdate {
	mutation := newAuthTokenMutation(c.config, OpUpdate)
	return &AuthTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthTokenClient) UpdateOne(_m *AuthToken) *AuthTokenUpdateOne {
	mutation := newAuthTokenMutation(c.config, OpUpdateOne, withAuthToken(_m))
	return &AuthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthTokenClient) UpdateOneID(id string) *AuthTokenUpdateOne {
	mutation := newAuthTokenMutation(c.config, OpUpdateOne, withAuthTokenID(id))
	return &AuthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthToken.
func (c *AuthTokenClient) Delete() *AuthTokenDelete {
	mutation := newAuthTokenMutation(c.config, OpDelete)
	return &AuthTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthTokenClient) DeleteOne(_m *AuthToken) *AuthTokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthTokenClient) DeleteOneID(id string) *AuthTokenDeleteOne {
	builder := c.Delete().Where(authtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthTokenDeleteOne{builder}
}

// Query returns a query builder for AuthToken.
func (c *AuthTokenClient) Query() *AuthTokenQuery {
	return &AuthTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthToken},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthToken entity by its id.
func (c *AuthTokenClient) Get(ctx context.Context, id string) (*AuthToken, error) {
	return c.Query().Where(authtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthTokenClient) GetX(ctx context.Context, id string) *AuthToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a AuthToken.
func (c *AuthTokenClient) QueryTeam(_m *AuthToken) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authtoken.Table, authtoken.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, authtoken.TeamTable, authtoken.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuthTokenClient) Hooks() []Hook {
	return c.hooks.AuthToken
}

// Interceptors returns the client interceptors.
func (c *AuthTokenClient) Interceptors() []Interceptor {
	return c.inters.AuthToken
}

func (c *AuthTokenClient) mutate(ctx context.Context, m *AuthTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthToken mutation op: %q", m.Op())
	}
}

// FacilityClient is a client for the Facility schema.
type FacilityClient struct {
	config
}

// NewFacilityClient returns a client for the Facility from the given config.
func NewFacilityClient(c config) *FacilityClient {
	return &FacilityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `facility.Hooks(f(g(h())))`.
func (c *FacilityClient) Use(hooks ...Hook) {
	c.hooks.Facility = append(c.hooks.Facility, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `facility.Intercept(f(g(h())))`.
func (c *FacilityClient) Intercept(interceptors ...Interceptor) {
	c.inters.Facility = append(c.inters.Facility, interceptors...)
}

// Create returns a builder for creating a Facility entity.
func (c *FacilityClient) Create() *FacilityCreate {
	mutation := newFacilityMutation(c.config, OpCreate)
	return &FacilityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Facility entities.
func (c *FacilityClient) CreateBulk(builders ...*FacilityCreate) *FacilityCreateBulk {
	return &FacilityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FacilityClient) MapCreateBulk(slice any, setFunc func(*FacilityCreate, int)) *FacilityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FacilityCreateBulk{err: fmt.Errorf("calling to FacilityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FacilityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FacilityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Facility.
func (c *FacilityClient) Update() *FacilityUpdate {
	mutation := newFacilityMutation(c.config, OpUpdate)
	return &FacilityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FacilityClient) UpdateOne(_m *Facility) *FacilityUpdateOne {
	mutation := newFacilityMutation(c.config, OpUpdateOne, withFacility(_m))
	return &FacilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FacilityClient) UpdateOneID(id string) *FacilityUpdateOne {
	mutation := newFacilityMutation(c.config, OpUpdateOne, withFacilityID(id))
	return &FacilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Facility.
func (c *FacilityClient) Delete() *FacilityDelete {
	mutation := newFacilityMutation(c.config, OpDelete)
	return &FacilityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FacilityClient) DeleteOne(_m *Facility) *FacilityDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FacilityClient) DeleteOneID(id string) *FacilityDeleteOne {
	builder := c.Delete().Where(facility.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FacilityDeleteOne{builder}
}

// Query returns a query builder for Facility.
func (c *FacilityClient) Query() *FacilityQuery {
	return &FacilityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFacility},
		inters: c.Interceptors(),
	}
}

// Get returns a Facility entity by its id.
func (c *FacilityClient) Get(ctx context.Context, id string) (*Facility, error) {
	return c.Query().Where(facility.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FacilityClient) GetX(ctx context.Context, id string) *Facility {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWatchConditions queries the watch_conditions edge of a Facility.
func (c *FacilityClient) QueryWatchConditions(_m *Facility) *WatchConditionQuery {
	query := (&WatchConditionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(facility.Table, facility.FieldID, id),
			sqlgraph.To(watchcondition.Table, watchcondition.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, facility.WatchConditionsTable, facility.WatchConditionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySlots queries the slots edge of a Facility.
func (c *FacilityClient) QuerySlots(_m *Facility) *SlotQuery {
	query := (&SlotClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(facility.Table, facility.FieldID, id),
			sqlgraph.To(slot.Table, slot.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, facility.SlotsTable, facility.SlotsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FacilityClient) Hooks() []Hook {
	return c.hooks.Facility
}

// Interceptors returns the client interceptors.
func (c *FacilityClient) Interceptors() []Interceptor {
	return c.inters.Facility
}

func (c *FacilityClient) mutate(ctx context.Context, m *FacilityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FacilityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FacilityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FacilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FacilityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Facility mutation op: %q", m.Op())
	}
}

// GroundClient is a client for the Ground schema.
type GroundClient struct {
	config
}

// NewGroundClient returns a client for the Ground from the given config.
func NewGroundClient(c config) *GroundClient {
	return &GroundClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ground.Hooks(f(g(h())))`.
func (c *GroundClient) Use(hooks ...Hook) {
	c.hooks.Ground = append(c.hooks.Ground, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ground.Intercept(f(g(h())))`.
func (c *GroundClient) Intercept(interceptors ...Interceptor) {
	c.inters.Ground = append(c.inters.Ground, interceptors...)
}

// Create returns a builder for creating a Ground entity.
func (c *GroundClient) Create() *GroundCreate {
	mutation := newGroundMutation(c.config, OpCreate)
	return &GroundCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Ground entities.
func (c *GroundClient) CreateBulk(builders ...*GroundCreate) *GroundCreateBulk {
	return &GroundCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GroundClient) MapCreateBulk(slice any, setFunc func(*GroundCreate, int)) *GroundCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GroundCreateBulk{err: fmt.Errorf("calling to GroundClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GroundCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GroundCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Ground.
func (c *GroundClient) Update() *GroundUpdate {
	mutation := newGroundMutation(c.config, OpUpdate)
	return &GroundUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroundClient) UpdateOne(_m *Ground) *GroundUpdateOne {
	mutation := newGroundMutation(c.config, OpUpdateOne, withGround(_m))
	return &GroundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroundClient) UpdateOneID(id string) *GroundUpdateOne {
	mutation := newGroundMutation(c.config, OpUpdateOne, withGroundID(id))
	return &GroundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Ground.
func (c *GroundClient) Delete() *GroundDelete {
	mutation := newGroundMutation(c.config, OpDelete)
	return &GroundDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroundClient) DeleteOne(_m *Ground) *GroundDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroundClient) DeleteOneID(id string) *GroundDeleteOne {
	builder := c.Delete().Where(ground.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroundDeleteOne{builder}
}

// Query returns a query builder for Ground.
func (c *GroundClient) Query() *GroundQuery {
	return &GroundQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGround},
		inters: c.Interceptors(),
	}
}

// Get returns a Ground entity by its id.
func (c *GroundClient) Get(ctx context.Context, id string) (*Ground, error) {
	return c.Query().Where(ground.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroundClient) GetX(ctx context.Context, id string) *Ground {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMunicipality queries the municipality edge of a Ground.
func (c *GroundClient) QueryMunicipality(_m *Ground) *MunicipalityQuery {
	query := (&MunicipalityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ground.Table, ground.FieldID, id),
			sqlgraph.To(municipality.Table, municipality.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ground.MunicipalityTable, ground.MunicipalityColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySlots queries the slots edge of a Ground.
func (c *GroundClient) QuerySlots(_m *Ground) *SlotQuery {
	query := (&SlotClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ground.Table, ground.FieldID, id),
			sqlgraph.To(slot.Table, slot.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ground.SlotsTable, ground.SlotsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroundClient) Hooks() []Hook {
	return c.hooks.Ground
}

// Interceptors returns the client interceptors.
func (c *GroundClient) Interceptors() []Interceptor {
	return c.inters.Ground
}

func (c *GroundClient) mutate(ctx context.Context, m *GroundMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroundCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroundUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroundDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Ground mutation op: %q", m.Op())
	}
}

// MunicipalityClient is a client for the Municipality schema.
type MunicipalityClient struct {
	config
}

// NewMunicipalityClient returns a client for the Municipality from the given config.
func NewMunicipalityClient(c config) *MunicipalityClient {
	return &MunicipalityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `municipality.Hooks(f(g(h())))`.
func (c *MunicipalityClient) Use(hooks ...Hook) {
	c.hooks.Municipality = append(c.hooks.Municipality, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `municipality.Intercept(f(g(h())))`.
func (c *MunicipalityClient) Intercept(interceptors ...Interceptor) {
	c.inters.Municipality = append(c.inters.Municipality, interceptors...)
}

// Create returns a builder for creating a Municipality entity.
func (c *MunicipalityClient) Create() *MunicipalityCreate {
	mutation := newMunicipalityMutation(c.config, OpCreate)
	return &MunicipalityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Municipality entities.
func (c *MunicipalityClient) CreateBulk(builders ...*MunicipalityCreate) *MunicipalityCreateBulk {
	return &MunicipalityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MunicipalityClient) MapCreateBulk(slice any, setFunc func(*MunicipalityCreate, int)) *MunicipalityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MunicipalityCreateBulk{err: fmt.Errorf("calling to MunicipalityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MunicipalityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MunicipalityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Municipality.
func (c *MunicipalityClient) Update() *MunicipalityUpdate {
	mutation := newMunicipalityMutation(c.config, OpUpdate)
	return &MunicipalityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MunicipalityClient) UpdateOne(_m *Municipality) *MunicipalityUpdateOne {
	mutation := newMunicipalityMutation(c.config, OpUpdateOne, withMunicipality(_m))
	return &MunicipalityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MunicipalityClient) UpdateOneID(id string) *MunicipalityUpdateOne {
	mutation := newMunicipalityMutation(c.config, OpUpdateOne, withMunicipalityID(id))
	return &MunicipalityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Municipality.
func (c *MunicipalityClient) Delete() *MunicipalityDelete {
	mutation := newMunicipalityMutation(c.config, OpDelete)
	return &MunicipalityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MunicipalityClient) DeleteOne(_m *Municipality) *MunicipalityDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MunicipalityClient) DeleteOneID(id string) *MunicipalityDeleteOne {
	builder := c.Delete().Where(municipality.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MunicipalityDeleteOne{builder}
}

// Query returns a query builder for Municipality.
func (c *MunicipalityClient) Query() *MunicipalityQuery {
	return &MunicipalityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMunicipality},
		inters: c.Interceptors(),
	}
}

// Get returns a Municipality entity by its id.
func (c *MunicipalityClient) Get(ctx context.Context, id string) (*Municipality, error) {
	return c.Query().Where(municipality.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MunicipalityClient) GetX(ctx context.Context, id string) *Municipality {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGrounds queries the grounds edge of a Municipality.
func (c *MunicipalityClient) QueryGrounds(_m *Municipality) *GroundQuery {
	query := (&GroundClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(municipality.Table, municipality.FieldID, id),
			sqlgraph.To(ground.Table, ground.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, municipality.GroundsTable, municipality.GroundsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySlots queries the slots edge of a Municipality.
func (c *MunicipalityClient) QuerySlots(_m *Municipality) *SlotQuery {
	query := (&SlotClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(municipality.Table, municipality.FieldID, id),
			sqlgraph.To(slot.Table, slot.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, municipality.SlotsTable, municipality.SlotsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScrapeJobs queries the scrape_jobs edge of a Municipality.
func (c *MunicipalityClient) QueryScrapeJobs(_m *Municipality) *ScrapeJobQuery {
	query := (&ScrapeJobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(municipality.Table, municipality.FieldID, id),
			sqlgraph.To(scrapejob.Table, scrapejob.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, municipality.ScrapeJobsTable, municipality.ScrapeJobsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MunicipalityClient) Hooks() []Hook {
	return c.hooks.Municipality
}

// Interceptors returns the client interceptors.
func (c *MunicipalityClient) Interceptors() []Interceptor {
	return c.inters.Municipality
}

func (c *MunicipalityClient) mutate(ctx context.Context, m *MunicipalityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MunicipalityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MunicipalityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MunicipalityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MunicipalityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Municipality mutation op: %q", m.Op())
	}
}

// NotificationClient is a client for the Notification schema.
type NotificationClient struct {
	config
}

// NewNotificationClient returns a client for the Notification from the given config.
func NewNotificationClient(c config) *NotificationClient {
	return &NotificationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notification.Hooks(f(g(h())))`.
func (c *NotificationClient) Use(hooks ...Hook) {
	c.hooks.Notification = append(c.hooks.Notification, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notification.Intercept(f(g(h())))`.
func (c *NotificationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Notification = append(c.inters.Notification, interceptors...)
}

// Create returns a builder for creating a Notification entity.
func (c *NotificationClient) Create() *NotificationCreate {
	mutation := newNotificationMutation(c.config, OpCreate)
	return &NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Notification entities.
func (c *NotificationClient) CreateBulk(builders ...*NotificationCreate) *NotificationCreateBulk {
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NotificationClient) MapCreateBulk(slice any, setFunc func(*NotificationCreate, int)) *NotificationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NotificationCreateBulk{err: fmt.Errorf("calling to NotificationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NotificationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Notification.
func (c *NotificationClient) Update() *NotificationUpdate {
	mutation := newNotificationMutation(c.config, OpUpdate)
	return &NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NotificationClient) UpdateOne(_m *Notification) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotification(_m))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NotificationClient) UpdateOneID(id string) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotificationID(id))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Notification.
func (c *NotificationClient) Delete() *NotificationDelete {
	mutation := newNotificationMutation(c.config, OpDelete)
	return &NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NotificationClient) DeleteOne(_m *Notification) *NotificationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NotificationClient) DeleteOneID(id string) *NotificationDeleteOne {
	builder := c.Delete().Where(notification.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NotificationDeleteOne{builder}
}

// Query returns a query builder for Notification.
func (c *NotificationClient) Query() *NotificationQuery {
	return &NotificationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNotification},
		inters: c.Interceptors(),
	}
}

// Get returns a Notification entity by its id.
func (c *NotificationClient) Get(ctx context.Context, id string) (*Notification, error) {
	return c.Query().Where(notification.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NotificationClient) GetX(ctx context.Context, id string) *Notification {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a Notification.
func (c *NotificationClient) QueryTeam(_m *Notification) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, notification.TeamTable, notification.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWatchCondition queries the watch_condition edge of a Notification.
func (c *NotificationClient) QueryWatchCondition(_m *Notification) *WatchConditionQuery {
	query := (&WatchConditionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(watchcondition.Table, watchcondition.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, notification.WatchConditionTable, notification.WatchConditionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySlot queries the slot edge of a Notification.
func (c *NotificationClient) QuerySlot(_m *Notification) *SlotQuery {
	query := (&SlotClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(slot.Table, slot.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, notification.SlotTable, notification.SlotColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NotificationClient) Hooks() []Hook {
	return c.hooks.Notification
}

// Interceptors returns the client interceptors.
func (c *NotificationClient) Interceptors() []Interceptor {
	return c.inters.Notification
}

func (c *NotificationClient) mutate(ctx context.Context, m *NotificationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Notification mutation op: %q", m.Op())
	}
}

// PromoCodeClient is a client for the PromoCode schema.
type PromoCodeClient struct {
	config
}

// NewPromoCodeClient returns a client for the PromoCode from the given config.
func NewPromoCodeClient(c config) *PromoCodeClient {
	return &PromoCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `promocode.Hooks(f(g(h())))`.
func (c *PromoCodeClient) Use(hooks ...Hook) {
	c.hooks.PromoCode = append(c.hooks.PromoCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `promocode.Intercept(f(g(h())))`.
func (c *PromoCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.PromoCode = append(c.inters.PromoCode, interceptors...)
}

// Create returns a builder for creating a PromoCode entity.
func (c *PromoCodeClient) Create() *PromoCodeCreate {
	mutation := newPromoCodeMutation(c.config, OpCreate)
	return &PromoCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PromoCode entities.
func (c *PromoCodeClient) CreateBulk(builders ...*PromoCodeCreate) *PromoCodeCreateBulk {
	return &PromoCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PromoCodeClient) MapCreateBulk(slice any, setFunc func(*PromoCodeCreate, int)) *PromoCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PromoCodeCreateBulk{err: fmt.Errorf("calling to PromoCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PromoCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PromoCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PromoCode.
func (c *PromoCodeClient) Update() *PromoCodeUpdate {
	mutation := newPromoCodeMutation(c.config, OpUpdate)
	return &PromoCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PromoCodeClient) UpdateOne(_m *PromoCode) *PromoCodeUpdateOne {
	mutation := newPromoCodeMutation(c.config, OpUpdateOne, withPromoCode(_m))
	return &PromoCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PromoCodeClient) UpdateOneID(id string) *PromoCodeUpdateOne {
	mutation := newPromoCodeMutation(c.config, OpUpdateOne, withPromoCodeID(id))
	return &PromoCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PromoCode.
func (c *PromoCodeClient) Delete() *PromoCodeDelete {
	mutation := newPromoCodeMutation(c.config, OpDelete)
	return &PromoCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PromoCodeClient) DeleteOne(_m *PromoCode) *PromoCodeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PromoCodeClient) DeleteOneID(id string) *PromoCodeDeleteOne {
	builder := c.Delete().Where(promocode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PromoCodeDeleteOne{builder}
}

// Query returns a query builder for PromoCode.
func (c *PromoCodeClient) Query() *PromoCodeQuery {
	return &PromoCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePromoCode},
		inters: c.Interceptors(),
	}
}

// Get returns a PromoCode entity by its id.
func (c *PromoCodeClient) Get(ctx context.Context, id string) (*PromoCode, error) {
	return c.Query().Where(promocode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PromoCodeClient) GetX(ctx context.Context, id string) *PromoCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsages queries the usages edge of a PromoCode.
func (c *PromoCodeClient) QueryUsages(_m *PromoCode) *PromoCodeUsageQuery {
	query := (&PromoCodeUsageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(promocode.Table, promocode.FieldID, id),
			sqlgraph.To(promocodeusage.Table, promocodeusage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, promocode.UsagesTable, promocode.UsagesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PromoCodeClient) Hooks() []Hook {
	return c.hooks.PromoCode
}

// Interceptors returns the client interceptors.
func (c *PromoCodeClient) Interceptors() []Interceptor {
	return c.inters.PromoCode
}

func (c *PromoCodeClient) mutate(ctx context.Context, m *PromoCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PromoCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PromoCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PromoCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PromoCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PromoCode mutation op: %q", m.Op())
	}
}

// PromoCodeUsageClient is a client for the PromoCodeUsage schema.
type PromoCodeUsageClient struct {
	config
}

// NewPromoCodeUsageClient returns a client for the PromoCodeUsage from the given config.
func NewPromoCodeUsageClient(c config) *PromoCodeUsageClient {
	return &PromoCodeUsageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `promocodeusage.Hooks(f(g(h())))`.
func (c *PromoCodeUsageClient) Use(hooks ...Hook) {
	c.hooks.PromoCodeUsage = append(c.hooks.PromoCodeUsage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `promocodeusage.Intercept(f(g(h())))`.
func (c *PromoCodeUsageClient) Intercept(interceptors ...Interceptor) {
	c.inters.PromoCodeUsage = append(c.inters.PromoCodeUsage, interceptors...)
}

// Create returns a builder for creating a PromoCodeUsage entity.
func (c *PromoCodeUsageClient) Create() *PromoCodeUsageCreate {
	mutation := newPromoCodeUsageMutation(c.config, OpCreate)
	return &PromoCodeUsageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PromoCodeUsage entities.
func (c *PromoCodeUsageClient) CreateBulk(builders ...*PromoCodeUsageCreate) *PromoCodeUsageCreateBulk {
	return &PromoCodeUsageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PromoCodeUsageClient) MapCreateBulk(slice any, setFunc func(*PromoCodeUsageCreate, int)) *PromoCodeUsageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PromoCodeUsageCreateBulk{err: fmt.Errorf("calling to PromoCodeUsageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PromoCodeUsageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PromoCodeUsageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PromoCodeUsage.
func (c *PromoCodeUsageClient) Update() *PromoCodeUsageUpdate {
	mutation := newPromoCodeUsageMutation(c.config, OpUpdate)
	return &PromoCodeUsageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PromoCodeUsageClient) UpdateOne(_m *PromoCodeUsage) *PromoCodeUsageUpdateOne {
	mutation := newPromoCodeUsageMutation(c.config, OpUpdateOne, withPromoCodeUsage(_m))
	return &PromoCodeUsageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PromoCodeUsageClient) UpdateOneID(id string) *PromoCodeUsageUpdateOne {
	mutation := newPromoCodeUsageMutation(c.config, OpUpdateOne, withPromoCodeUsageID(id))
	return &PromoCodeUsageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PromoCodeUsage.
func (c *PromoCodeUsageClient) Delete() *PromoCodeUsageDelete {
	mutation := newPromoCodeUsageMutation(c.config, OpDelete)
	return &PromoCodeUsageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PromoCodeUsageClient) DeleteOne(_m *PromoCodeUsage) *PromoCodeUsageDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PromoCodeUsageClient) DeleteOneID(id string) *PromoCodeUsageDeleteOne {
	builder := c.Delete().Where(promocodeusage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PromoCodeUsageDeleteOne{builder}
}

// Query returns a query builder for PromoCodeUsage.
func (c *PromoCodeUsageClient) Query() *PromoCodeUsageQuery {
	return &PromoCodeUsageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePromoCodeUsage},
		inters: c.Interceptors(),
	}
}

// Get returns a PromoCodeUsage entity by its id.
func (c *PromoCodeUsageClient) Get(ctx context.Context, id string) (*PromoCodeUsage, error) {
	return c.Query().Where(promocodeusage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PromoCodeUsageClient) GetX(ctx context.Context, id string) *PromoCodeUsage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPromoCode queries the promo_code edge of a PromoCodeUsage.
func (c *PromoCodeUsageClient) QueryPromoCode(_m *PromoCodeUsage) *PromoCodeQuery {
	query := (&PromoCodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(promocodeusage.Table, promocodeusage.FieldID, id),
			sqlgraph.To(promocode.Table, promocode.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, promocodeusage.PromoCodeTable, promocodeusage.PromoCodeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the team edge of a PromoCodeUsage.
func (c *PromoCodeUsageClient) QueryTeam(_m *PromoCodeUsage) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(promocodeusage.Table, promocodeusage.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, promocodeusage.TeamTable, promocodeusage.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PromoCodeUsageClient) Hooks() []Hook {
	return c.hooks.PromoCodeUsage
}

// Interceptors returns the client interceptors.
func (c *PromoCodeUsageClient) Interceptors() []Interceptor {
	return c.inters.PromoCodeUsage
}

func (c *PromoCodeUsageClient) mutate(ctx context.Context, m *PromoCodeUsageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PromoCodeUsageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PromoCodeUsageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PromoCodeUsageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PromoCodeUsageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PromoCodeUsage mutation op: %q", m.Op())
	}
}

// ScrapeJobClient is a client for the ScrapeJob schema.
type ScrapeJobClient struct {
	config
}

// NewScrapeJobClient returns a client for the ScrapeJob from the given config.
func NewScrapeJobClient(c config) *ScrapeJobClient {
	return &ScrapeJobClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scrapejob.Hooks(f(g(h())))`.
func (c *ScrapeJobClient) Use(hooks ...Hook) {
	c.hooks.ScrapeJob = append(c.hooks.ScrapeJob, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scrapejob.Intercept(f(g(h())))`.
func (c *ScrapeJobClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScrapeJob = append(c.inters.ScrapeJob, interceptors...)
}

// Create returns a builder for creating a ScrapeJob entity.
func (c *ScrapeJobClient) Create() *ScrapeJobCreate {
	mutation := newScrapeJobMutation(c.config, OpCreate)
	return &ScrapeJobCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScrapeJob entities.
func (c *ScrapeJobClient) CreateBulk(builders ...*ScrapeJobCreate) *ScrapeJobCreateBulk {
	return &ScrapeJobCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScrapeJobClient) MapCreateBulk(slice any, setFunc func(*ScrapeJobCreate, int)) *ScrapeJobCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScrapeJobCreateBulk{err: fmt.Errorf("calling to ScrapeJobClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScrapeJobCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScrapeJobCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScrapeJob.
func (c *ScrapeJobClient) Update() *ScrapeJobUpdate {
	mutation := newScrapeJobMutation(c.config, OpUpdate)
	return &ScrapeJobUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScrapeJobClient) UpdateOne(_m *ScrapeJob) *ScrapeJobUpdateOne {
	mutation := newScrapeJobMutation(c.config, OpUpdateOne, withScrapeJob(_m))
	return &ScrapeJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScrapeJobClient) UpdateOneID(id string) *ScrapeJobUpdateOne {
	mutation := newScrapeJobMutation(c.config, OpUpdateOne, withScrapeJobID(id))
	return &ScrapeJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScrapeJob.
func (c *ScrapeJobClient) Delete() *ScrapeJobDelete {
	mutation := newScrapeJobMutation(c.config, OpDelete)
	return &ScrapeJobDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScrapeJobClient) DeleteOne(_m *ScrapeJob) *ScrapeJobDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScrapeJobClient) DeleteOneID(id string) *ScrapeJobDeleteOne {
	builder := c.Delete().Where(scrapejob.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScrapeJobDeleteOne{builder}
}

// Query returns a query builder for ScrapeJob.
func (c *ScrapeJobClient) Query() *ScrapeJobQuery {
	return &ScrapeJobQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScrapeJob},
		inters: c.Interceptors(),
	}
}

// Get returns a ScrapeJob entity by its id.
func (c *ScrapeJobClient) Get(ctx context.Context, id string) (*ScrapeJob, error) {
	return c.Query().Where(scrapejob.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScrapeJobClient) GetX(ctx context.Context, id string) *ScrapeJob {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMunicipality queries the municipality edge of a ScrapeJob.
func (c *ScrapeJobClient) QueryMunicipality(_m *ScrapeJob) *MunicipalityQuery {
	query := (&MunicipalityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scrapejob.Table, scrapejob.FieldID, id),
			sqlgraph.To(municipality.Table, municipality.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scrapejob.MunicipalityTable, scrapejob.MunicipalityColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScrapeJobClient) Hooks() []Hook {
	return c.hooks.ScrapeJob
}

// Interceptors returns the client interceptors.
func (c *ScrapeJobClient) Interceptors() []Interceptor {
	return c.inters.ScrapeJob
}

func (c *ScrapeJobClient) mutate(ctx context.Context, m *ScrapeJobMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScrapeJobCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScrapeJobUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScrapeJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScrapeJobDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScrapeJob mutation op: %q", m.Op())
	}
}

// SlotClient is a client for the Slot schema.
type SlotClient struct {
	config
}

// NewSlotClient returns a client for the Slot from the given config.
func NewSlotClient(c config) *SlotClient {
	return &SlotClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `slot.Hooks(f(g(h())))`.
func (c *SlotClient) Use(hooks ...Hook) {
	c.hooks.Slot = append(c.hooks.Slot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `slot.Intercept(f(g(h())))`.
func (c *SlotClient) Intercept(interceptors ...Interceptor) {
	c.inters.Slot = append(c.inters.Slot, interceptors...)
}

// Create returns a builder for creating a Slot entity.
func (c *SlotClient) Create() *SlotCreate {
	mutation := newSlotMutation(c.config, OpCreate)
	return &SlotCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Slot entities.
func (c *SlotClient) CreateBulk(builders ...*SlotCreate) *SlotCreateBulk {
	return &SlotCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SlotClient) MapCreateBulk(slice any, setFunc func(*SlotCreate, int)) *SlotCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SlotCreateBulk{err: fmt.Errorf("calling to SlotClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SlotCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SlotCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Slot.
func (c *SlotClient) Update() *SlotUpdate {
	mutation := newSlotMutation(c.config, OpUpdate)
	return &SlotUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SlotClient) UpdateOne(_m *Slot) *SlotUpdateOne {
	mutation := newSlotMutation(c.config, OpUpdateOne, withSlot(_m))
	return &SlotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SlotClient) UpdateOneID(id string) *SlotUpdateOne {
	mutation := newSlotMutation(c.config, OpUpdateOne, withSlotID(id))
	return &SlotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Slot.
func (c *SlotClient) Delete() *SlotDelete {
	mutation := newSlotMutation(c.config, OpDelete)
	return &SlotDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SlotClient) DeleteOne(_m *Slot) *SlotDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SlotClient) DeleteOneID(id string) *SlotDeleteOne {
	builder := c.Delete().Where(slot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SlotDeleteOne{builder}
}

// Query returns a query builder for Slot.
func (c *SlotClient) Query() *SlotQuery {
	return &SlotQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSlot},
		inters: c.Interceptors(),
	}
}

// Get returns a Slot entity by its id.
func (c *SlotClient) Get(ctx context.Context, id string) (*Slot, error) {
	return c.Query().Where(slot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SlotClient) GetX(ctx context.Context, id string) *Slot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFacility queries the facility edge of a Slot.
func (c *SlotClient) QueryFacility(_m *Slot) *FacilityQuery {
	query := (&FacilityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(slot.Table, slot.FieldID, id),
			sqlgraph.To(facility.Table, facility.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, slot.FacilityTable, slot.FacilityColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMunicipality queries the municipality edge of a Slot.
func (c *SlotClient) QueryMunicipality(_m *Slot) *MunicipalityQuery {
	query := (&MunicipalityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(slot.Table, slot.FieldID, id),
			sqlgraph.To(municipality.Table, municipality.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, slot.MunicipalityTable, slot.MunicipalityColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGround queries the ground edge of a Slot.
func (c *SlotClient) QueryGround(_m *Slot) *GroundQuery {
	query := (&GroundClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(slot.Table, slot.FieldID, id),
			sqlgraph.To(ground.Table, ground.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, slot.GroundTable, slot.GroundColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a Slot.
func (c *SlotClient) QueryNotifications(_m *Slot) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(slot.Table, slot.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, slot.NotificationsTable, slot.NotificationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SlotClient) Hooks() []Hook {
	return c.hooks.Slot
}

// Interceptors returns the client interceptors.
func (c *SlotClient) Interceptors() []Interceptor {
	return c.inters.Slot
}

func (c *SlotClient) mutate(ctx context.Context, m *SlotMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SlotCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SlotUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SlotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SlotDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Slot mutation op: %q", m.Op())
	}
}

// SupportMessageClient is a client for the SupportMessage schema.
type SupportMessageClient struct {
	config
}

// NewSupportMessageClient returns a client for the SupportMessage from the given config.
func NewSupportMessageClient(c config) *SupportMessageClient {
	return &SupportMessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `supportmessage.Hooks(f(g(h())))`.
func (c *SupportMessageClient) Use(hooks ...Hook) {
	c.hooks.SupportMessage = append(c.hooks.SupportMessage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `supportmessage.Intercept(f(g(h())))`.
func (c *SupportMessageClient) Intercept(interceptors ...Interceptor) {
	c.inters.SupportMessage = append(c.inters.SupportMessage, interceptors...)
}

// Create returns a builder for creating a SupportMessage entity.
func (c *SupportMessageClient) Create() *SupportMessageCreate {
	mutation := newSupportMessageMutation(c.config, OpCreate)
	return &SupportMessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SupportMessage entities.
func (c *SupportMessageClient) CreateBulk(builders ...*SupportMessageCreate) *SupportMessageCreateBulk {
	return &SupportMessageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SupportMessageClient) MapCreateBulk(slice any, setFunc func(*SupportMessageCreate, int)) *SupportMessageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SupportMessageCreateBulk{err: fmt.Errorf("calling to SupportMessageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SupportMessageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SupportMessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SupportMessage.
func (c *SupportMessageClient) Update() *SupportMessageUpdate {
	mutation := newSupportMessageMutation(c.config, OpUpdate)
	return &SupportMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SupportMessageClient) UpdateOne(_m *SupportMessage) *SupportMessageUpdateOne {
	mutation := newSupportMessageMutation(c.config, OpUpdateOne, withSupportMessage(_m))
	return &SupportMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SupportMessageClient) UpdateOneID(id string) *SupportMessageUpdateOne {
	mutation := newSupportMessageMutation(c.config, OpUpdateOne, withSupportMessageID(id))
	return &SupportMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SupportMessage.
func (c *SupportMessageClient) Delete() *SupportMessageDelete {
	mutation := newSupportMessageMutation(c.config, OpDelete)
	return &SupportMessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SupportMessageClient) DeleteOne(_m *SupportMessage) *SupportMessageDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SupportMessageClient) DeleteOneID(id string) *SupportMessageDeleteOne {
	builder := c.Delete().Where(supportmessage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SupportMessageDeleteOne{builder}
}

// Query returns a query builder for SupportMessage.
func (c *SupportMessageClient) Query() *SupportMessageQuery {
	return &SupportMessageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSupportMessage},
		inters: c.Interceptors(),
	}
}

// Get returns a SupportMessage entity by its id.
func (c *SupportMessageClient) Get(ctx context.Context, id string) (*SupportMessage, error) {
	return c.Query().Where(supportmessage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SupportMessageClient) GetX(ctx context.Context, id string) *SupportMessage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTicket queries the ticket edge of a SupportMessage.
func (c *SupportMessageClient) QueryTicket(_m *SupportMessage) *SupportTicketQuery {
	query := (&SupportTicketClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(supportmessage.Table, supportmessage.FieldID, id),
			sqlgraph.To(supportticket.Table, supportticket.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, supportmessage.TicketTable, supportmessage.TicketColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SupportMessageClient) Hooks() []Hook {
	return c.hooks.SupportMessage
}

// Interceptors returns the client interceptors.
func (c *SupportMessageClient) Interceptors() []Interceptor {
	return c.inters.SupportMessage
}

func (c *SupportMessageClient) mutate(ctx context.Context, m *SupportMessageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SupportMessageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SupportMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SupportMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SupportMessageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SupportMessage mutation op: %q", m.Op())
	}
}

// SupportTicketClient is a client for the SupportTicket schema.
type SupportTicketClient struct {
	config
}

// NewSupportTicketClient returns a client for the SupportTicket from the given config.
func NewSupportTicketClient(c config) *SupportTicketClient {
	return &SupportTicketClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `supportticket.Hooks(f(g(h())))`.
func (c *SupportTicketClient) Use(hooks ...Hook) {
	c.hooks.SupportTicket = append(c.hooks.SupportTicket, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `supportticket.Intercept(f(g(h())))`.
func (c *SupportTicketClient) Intercept(interceptors ...Interceptor) {
	c.inters.SupportTicket = append(c.inters.SupportTicket, interceptors...)
}

// Create returns a builder for creating a SupportTicket entity.
func (c *SupportTicketClient) Create() *SupportTicketCreate {
	mutation := newSupportTicketMutation(c.config, OpCreate)
	return &SupportTicketCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SupportTicket entities.
func (c *SupportTicketClient) CreateBulk(builders ...*SupportTicketCreate) *SupportTicketCreateBulk {
	return &SupportTicketCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SupportTicketClient) MapCreateBulk(slice any, setFunc func(*SupportTicketCreate, int)) *SupportTicketCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SupportTicketCreateBulk{err: fmt.Errorf("calling to SupportTicketClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SupportTicketCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SupportTicketCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SupportTicket.
func (c *SupportTicketClient) Update() *SupportTicketUpdate {
	mutation := newSupportTicketMutation(c.config, OpUpdate)
	return &SupportTicketUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SupportTicketClient) UpdateOne(_m *SupportTicket) *SupportTicketUpdateOne {
	mutation := newSupportTicketMutation(c.config, OpUpdateOne, withSupportTicket(_m))
	return &SupportTicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SupportTicketClient) UpdateOneID(id string) *SupportTicketUpdateOne {
	mutation := newSupportTicketMutation(c.config, OpUpdateOne, withSupportTicketID(id))
	return &SupportTicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SupportTicket.
func (c *SupportTicketClient) Delete() *SupportTicketDelete {
	mutation := newSupportTicketMutation(c.config, OpDelete)
	return &SupportTicketDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SupportTicketClient) DeleteOne(_m *SupportTicket) *SupportTicketDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SupportTicketClient) DeleteOneID(id string) *SupportTicketDeleteOne {
	builder := c.Delete().Where(supportticket.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SupportTicketDeleteOne{builder}
}

// Query returns a query builder for SupportTicket.
func (c *SupportTicketClient) Query() *SupportTicketQuery {
	return &SupportTicketQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSupportTicket},
		inters: c.Interceptors(),
	}
}

// Get returns a SupportTicket entity by its id.
func (c *SupportTicketClient) Get(ctx context.Context, id string) (*SupportTicket, error) {
	return c.Query().Where(supportticket.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SupportTicketClient) GetX(ctx context.Context, id string) *SupportTicket {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a SupportTicket.
func (c *SupportTicketClient) QueryTeam(_m *SupportTicket) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(supportticket.Table, supportticket.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, supportticket.TeamTable, supportticket.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessages queries the messages edge of a SupportTicket.
func (c *SupportTicketClient) QueryMessages(_m *SupportTicket) *SupportMessageQuery {
	query := (&SupportMessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(supportticket.Table, supportticket.FieldID, id),
			sqlgraph.To(supportmessage.Table, supportmessage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, supportticket.MessagesTable, supportticket.MessagesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SupportTicketClient) Hooks() []Hook {
	return c.hooks.SupportTicket
}

// Interceptors returns the client interceptors.
func (c *SupportTicketClient) Interceptors() []Interceptor {
	return c.inters.SupportTicket
}

func (c *SupportTicketClient) mutate(ctx context.Context, m *SupportTicketMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SupportTicketCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SupportTicketUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SupportTicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SupportTicketDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SupportTicket mutation op: %q", m.Op())
	}
}

// TeamClient is a client for the Team schema.
type TeamClient struct {
	config
}

// NewTeamClient returns a client for the Team from the given config.
func NewTeamClient(c config) *TeamClient {
	return &TeamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `team.Hooks(f(g(h())))`.
func (c *TeamClient) Use(hooks ...Hook) {
	c.hooks.Team = append(c.hooks.Team, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `team.Intercept(f(g(h())))`.
func (c *TeamClient) Intercept(interceptors ...Interceptor) {
	c.inters.Team = append(c.inters.Team, interceptors...)
}

// Create returns a builder for creating a Team entity.
func (c *TeamClient) Create() *TeamCreate {
	mutation := newTeamMutation(c.config, OpCreate)
	return &TeamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Team entities.
func (c *TeamClient) CreateBulk(builders ...*TeamCreate) *TeamCreateBulk {
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TeamClient) MapCreateBulk(slice any, setFunc func(*TeamCreate, int)) *TeamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TeamCreateBulk{err: fmt.Errorf("calling to TeamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TeamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Team.
func (c *TeamClient) Update() *TeamUpdate {
	mutation := newTeamMutation(c.config, OpUpdate)
	return &TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TeamClient) UpdateOne(_m *Team) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeam(_m))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TeamClient) UpdateOneID(id string) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeamID(id))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Team.
func (c *TeamClient) Delete() *TeamDelete {
	mutation := newTeamMutation(c.config, OpDelete)
	return &TeamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TeamClient) DeleteOne(_m *Team) *TeamDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TeamClient) DeleteOneID(id string) *TeamDeleteOne {
	builder := c.Delete().Where(team.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TeamDeleteOne{builder}
}

// Query returns a query builder for Team.
func (c *TeamClient) Query() *TeamQuery {
	return &TeamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTeam},
		inters: c.Interceptors(),
	}
}

// Get returns a Team entity by its id.
func (c *TeamClient) Get(ctx context.Context, id string) (*Team, error) {
	return c.Query().Where(team.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TeamClient) GetX(ctx context.Context, id string) *Team {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWatchConditions queries the watch_conditions edge of a Team.
func (c *TeamClient) QueryWatchConditions(_m *Team) *WatchConditionQuery {
	query := (&WatchConditionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(watchcondition.Table, watchcondition.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.WatchConditionsTable, team.WatchConditionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a Team.
func (c *TeamClient) QueryNotifications(_m *Team) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.NotificationsTable, team.NotificationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthTokens queries the auth_tokens edge of a Team.
func (c *TeamClient) QueryAuthTokens(_m *Team) *AuthTokenQuery {
	query := (&AuthTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(authtoken.Table, authtoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.AuthTokensTable, team.AuthTokensColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySupportTickets queries the support_tickets edge of a Team.
func (c *TeamClient) QuerySupportTickets(_m *Team) *SupportTicketQuery {
	query := (&SupportTicketClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(supportticket.Table, supportticket.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.SupportTicketsTable, team.SupportTicketsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPromoCodeUsages queries the promo_code_usages edge of a Team.
func (c *TeamClient) QueryPromoCodeUsages(_m *Team) *PromoCodeUsageQuery {
	query := (&PromoCodeUsageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(promocodeusage.Table, promocodeusage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.PromoCodeUsagesTable, team.PromoCodeUsagesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TeamClient) Hooks() []Hook {
	return c.hooks.Team
}

// Interceptors returns the client interceptors.
func (c *TeamClient) Interceptors() []Interceptor {
	return c.inters.Team
}

func (c *TeamClient) mutate(ctx context.Context, m *TeamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TeamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TeamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Team mutation op: %q", m.Op())
	}
}

// WatchConditionClient is a client for the WatchCondition schema.
type WatchConditionClient struct {
	config
}

// NewWatchConditionClient returns a client for the WatchCondition from the given config.
func NewWatchConditionClient(c config) *WatchConditionClient {
	return &WatchConditionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `watchcondition.Hooks(f(g(h())))`.
func (c *WatchConditionClient) Use(hooks ...Hook) {
	c.hooks.WatchCondition = append(c.hooks.WatchCondition, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `watchcondition.Intercept(f(g(h())))`.
func (c *WatchConditionClient) Intercept(interceptors ...Interceptor) {
	c.inters.WatchCondition = append(c.inters.WatchCondition, interceptors...)
}

// Create returns a builder for creating a WatchCondition entity.
func (c *WatchConditionClient) Create() *WatchConditionCreate {
	mutation := newWatchConditionMutation(c.config, OpCreate)
	return &WatchConditionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WatchCondition entities.
func (c *WatchConditionClient) CreateBulk(builders ...*WatchConditionCreate) *WatchConditionCreateBulk {
	return &WatchConditionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WatchConditionClient) MapCreateBulk(slice any, setFunc func(*WatchConditionCreate, int)) *WatchConditionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WatchConditionCreateBulk{err: fmt.Errorf("calling to WatchConditionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WatchConditionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WatchConditionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WatchCondition.
func (c *WatchConditionClient) Update() *WatchConditionUpdate {
	mutation := newWatchConditionMutation(c.config, OpUpdate)
	return &WatchConditionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WatchConditionClient) UpdateOne(_m *WatchCondition) *WatchConditionUpdateOne {
	mutation := newWatchConditionMutation(c.config, OpUpdateOne, withWatchCondition(_m))
	return &WatchConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WatchConditionClient) UpdateOneID(id string) *WatchConditionUpdateOne {
	mutation := newWatchConditionMutation(c.config, OpUpdateOne, withWatchConditionID(id))
	return &WatchConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WatchCondition.
func (c *WatchConditionClient) Delete() *WatchConditionDelete {
	mutation := newWatchConditionMutation(c.config, OpDelete)
	return &WatchConditionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WatchConditionClient) DeleteOne(_m *WatchCondition) *WatchConditionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WatchConditionClient) DeleteOneID(id string) *WatchConditionDeleteOne {
	builder := c.Delete().Where(watchcondition.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WatchConditionDeleteOne{builder}
}

// Query returns a query builder for WatchCondition.
func (c *WatchConditionClient) Query() *WatchConditionQuery {
	return &WatchConditionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWatchCondition},
		inters: c.Interceptors(),
	}
}

// Get returns a WatchCondition entity by its id.
func (c *WatchConditionClient) Get(ctx context.Context, id string) (*WatchCondition, error) {
	return c.Query().Where(watchcondition.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WatchConditionClient) GetX(ctx context.Context, id string) *WatchCondition {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a WatchCondition.
func (c *WatchConditionClient) QueryTeam(_m *WatchCondition) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(watchcondition.Table, watchcondition.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, watchcondition.TeamTable, watchcondition.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFacility queries the facility edge of a WatchCondition.
func (c *WatchConditionClient) QueryFacility(_m *WatchCondition) *FacilityQuery {
	query := (&FacilityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(watchcondition.Table, watchcondition.FieldID, id),
			sqlgraph.To(facility.Table, facility.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, watchcondition.FacilityTable, watchcondition.FacilityColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a WatchCondition.
func (c *WatchConditionClient) QueryNotifications(_m *WatchCondition) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(watchcondition.Table, watchcondition.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, watchcondition.NotificationsTable, watchcondition.NotificationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WatchConditionClient) Hooks() []Hook {
	return c.hooks.WatchCondition
}

// Interceptors returns the client interceptors.
func (c *WatchConditionClient) Interceptors() []Interceptor {
	return c.inters.WatchCondition
}

func (c *WatchConditionClient) mutate(ctx context.Context, m *WatchConditionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WatchConditionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WatchConditionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WatchConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WatchConditionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WatchCondition mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AuthToken, Facility, Ground, Municipality, Notification, PromoCode,
		PromoCodeUsage, ScrapeJob, Slot, SupportMessage, SupportTicket, Team,
		WatchCondition []ent.Hook
	}
	inters struct {
		AuthToken, Facility, Ground, Municipality, Notification, PromoCode,
		PromoCodeUsage, ScrapeJob, Slot, SupportMessage, SupportTicket, Team,
		WatchCondition []ent.Interceptor
	}
)
