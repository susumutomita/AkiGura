// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"srv.exe.dev/ent/authtoken"
	"srv.exe.dev/ent/facility"
	"srv.exe.dev/ent/ground"
	"srv.exe.dev/ent/municipality"
	"srv.exe.dev/ent/notification"
	"srv.exe.dev/ent/predicate"
	"srv.exe.dev/ent/promocode"
	"srv.exe.dev/ent/promocodeusage"
	"srv.exe.dev/ent/scrapejob"
	"srv.exe.dev/ent/slot"
	"srv.exe.dev/ent/supportmessage"
	"srv.exe.dev/ent/supportticket"
	"srv.exe.dev/ent/team"
	"srv.exe.dev/ent/watchcondition"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuthToken      = "AuthToken"
	TypeFacility       = "Facility"
	TypeGround         = "Ground"
	TypeMunicipality   = "Municipality"
	TypeNotification   = "Notification"
	TypePromoCode      = "PromoCode"
	TypePromoCodeUsage = "PromoCodeUsage"
	TypeScrapeJob      = "ScrapeJob"
	TypeSlot           = "Slot"
	TypeSupportMessage = "SupportMessage"
	TypeSupportTicket  = "SupportTicket"
	TypeTeam           = "Team"
	TypeWatchCondition = "WatchCondition"
)

// AuthTokenMutation represents an operation that mutates the AuthToken nodes in the graph.
type AuthTokenMutation struct {
	config
	op            Op
	typ           string
	id            *string
	token         *string
	expires_at    *time.Time
	used_at       *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	team          *string
	clearedteam   bool
	done          bool
	oldValue      func(context.Context) (*AuthToken, error)
	predicates    []predicate.AuthToken
}

var _ ent.Mutation = (*AuthTokenMutation)(nil)

// authtokenOption allows management of the mutation configuration using functional options.
type authtokenOption func(*AuthTokenMutation)

// newAuthTokenMutation creates new mutation for the AuthToken entity.
func newAuthTokenMutation(c config, op Op, opts ...authtokenOption) *AuthTokenMutation {
	m := &AuthTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthTokenID sets the ID field of the mutation.
func withAuthTokenID(id string) authtokenOption {
	return func(m *AuthTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthToken
		)
		m.oldValue = func(ctx context.Context) (*AuthToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthToken sets the old AuthToken of the mutation.
func withAuthToken(node *AuthToken) authtokenOption {
	return func(m *AuthTokenMutation) {
		m.oldValue = func(context.Context) (*AuthToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthToken entities.
func (m *AuthTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToken sets the "token" field.
func (m *AuthTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *AuthTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *AuthTokenMutation) ResetToken() {
	m.token = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *AuthTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AuthTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AuthTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUsedAt sets the "used_at" field.
func (m *AuthTokenMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *AuthTokenMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *AuthTokenMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[authtoken.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *AuthTokenMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[authtoken.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *AuthTokenMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, authtoken.FieldUsedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *AuthTokenMutation) SetTeamID(id string) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *AuthTokenMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *AuthTokenMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *AuthTokenMutation) TeamID() (id string, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *AuthTokenMutation) TeamIDs() (ids []string) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *AuthTokenMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the AuthTokenMutation builder.
func (m *AuthTokenMutation) Where(ps ...predicate.AuthToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthToken).
func (m *AuthTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthTokenMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.token != nil {
		fields = append(fields, authtoken.FieldToken)
	}
	if m.expires_at != nil {
		fields = append(fields, authtoken.FieldExpiresAt)
	}
	if m.used_at != nil {
		fields = append(fields, authtoken.FieldUsedAt)
	}
	if m.created_at != nil {
		fields = append(fields, authtoken.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authtoken.FieldToken:
		return m.Token()
	case authtoken.FieldExpiresAt:
		return m.ExpiresAt()
	case authtoken.FieldUsedAt:
		return m.UsedAt()
	case authtoken.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authtoken.FieldToken:
		return m.OldToken(ctx)
	case authtoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case authtoken.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case authtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuthToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authtoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case authtoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case authtoken.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case authtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuthToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authtoken.FieldUsedAt) {
		fields = append(fields, authtoken.FieldUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthTokenMutation) ClearField(name string) error {
	switch name {
	case authtoken.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	}
	return fmt.Errorf("unknown AuthToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthTokenMutation) ResetField(name string) error {
	switch name {
	case authtoken.FieldToken:
		m.ResetToken()
		return nil
	case authtoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case authtoken.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case authtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AuthToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.team != nil {
		edges = append(edges, authtoken.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authtoken.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedteam {
		edges = append(edges, authtoken.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case authtoken.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthTokenMutation) ClearEdge(name string) error {
	switch name {
	case authtoken.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown AuthToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthTokenMutation) ResetEdge(name string) error {
	switch name {
	case authtoken.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown AuthToken edge %s", name)
}

// FacilityMutation represents an operation that mutates the Facility nodes in the graph.
type FacilityMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	name                    *string
	municipality            *string
	scraper_type            *string
	url                     *string
	enabled                 *bool
	created_at              *time.Time
	clearedFields           map[string]struct{}
	watch_conditions        map[string]struct{}
	removedwatch_conditions map[string]struct{}
	clearedwatch_conditions bool
	slots                   map[string]struct{}
	removedslots            map[string]struct{}
	clearedslots            bool
	done                    bool
	oldValue                func(context.Context) (*Facility, error)
	predicates              []predicate.Facility
}

var _ ent.Mutation = (*FacilityMutation)(nil)

// facilityOption allows management of the mutation configuration using functional options.
type facilityOption func(*FacilityMutation)

// newFacilityMutation creates new mutation for the Facility entity.
func newFacilityMutation(c config, op Op, opts ...facilityOption) *FacilityMutation {
	m := &FacilityMutation{
		config:        c,
		op:            op,
		typ:           TypeFacility,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFacilityID sets the ID field of the mutation.
func withFacilityID(id string) facilityOption {
	return func(m *FacilityMutation) {
		var (
			err   error
			once  sync.Once
			value *Facility
		)
		m.oldValue = func(ctx context.Context) (*Facility, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Facility.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFacility sets the old Facility of the mutation.
func withFacility(node *Facility) facilityOption {
	return func(m *FacilityMutation) {
		m.oldValue = func(context.Context) (*Facility, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FacilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FacilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Facility entities.
func (m *FacilityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FacilityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FacilityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Facility.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FacilityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FacilityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FacilityMutation) ResetName() {
	m.name = nil
}

// SetMunicipality sets the "municipality" field.
func (m *FacilityMutation) SetMunicipality(s string) {
	m.municipality = &s
}

// Municipality returns the value of the "municipality" field in the mutation.
func (m *FacilityMutation) Municipality() (r string, exists bool) {
	v := m.municipality
	if v == nil {
		return
	}
	return *v, true
}

// OldMunicipality returns the old "municipality" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldMunicipality(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMunicipality is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMunicipality requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMunicipality: %w", err)
	}
	return oldValue.Municipality, nil
}

// ResetMunicipality resets all changes to the "municipality" field.
func (m *FacilityMutation) ResetMunicipality() {
	m.municipality = nil
}

// SetScraperType sets the "scraper_type" field.
func (m *FacilityMutation) SetScraperType(s string) {
	m.scraper_type = &s
}

// ScraperType returns the value of the "scraper_type" field in the mutation.
func (m *FacilityMutation) ScraperType() (r string, exists bool) {
	v := m.scraper_type
	if v == nil {
		return
	}
	return *v, true
}

// OldScraperType returns the old "scraper_type" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldScraperType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScraperType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScraperType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScraperType: %w", err)
	}
	return oldValue.ScraperType, nil
}

// ResetScraperType resets all changes to the "scraper_type" field.
func (m *FacilityMutation) ResetScraperType() {
	m.scraper_type = nil
}

// SetURL sets the "url" field.
func (m *FacilityMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *FacilityMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *FacilityMutation) ResetURL() {
	m.url = nil
}

// SetEnabled sets the "enabled" field.
func (m *FacilityMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *FacilityMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *FacilityMutation) ResetEnabled() {
	m.enabled = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FacilityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FacilityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Facility entity.
// If the Facility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FacilityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddWatchConditionIDs adds the "watch_conditions" edge to the WatchCondition entity by ids.
func (m *FacilityMutation) AddWatchConditionIDs(ids ...string) {
	if m.watch_conditions == nil {
		m.watch_conditions = make(map[string]struct{})
	}
	for i := range ids {
		m.watch_conditions[ids[i]] = struct{}{}
	}
}

// ClearWatchConditions clears the "watch_conditions" edge to the WatchCondition entity.
func (m *FacilityMutation) ClearWatchConditions() {
	m.clearedwatch_conditions = true
}

// WatchConditionsCleared reports if the "watch_conditions" edge to the WatchCondition entity was cleared.
func (m *FacilityMutation) WatchConditionsCleared() bool {
	return m.clearedwatch_conditions
}

// RemoveWatchConditionIDs removes the "watch_conditions" edge to the WatchCondition entity by IDs.
func (m *FacilityMutation) RemoveWatchConditionIDs(ids ...string) {
	if m.removedwatch_conditions == nil {
		m.removedwatch_conditions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.watch_conditions, ids[i])
		m.removedwatch_conditions[ids[i]] = struct{}{}
	}
}

// RemovedWatchConditions returns the removed IDs of the "watch_conditions" edge to the WatchCondition entity.
func (m *FacilityMutation) RemovedWatchConditionsIDs() (ids []string) {
	for id := range m.removedwatch_conditions {
		ids = append(ids, id)
	}
	return
}

// WatchConditionsIDs returns the "watch_conditions" edge IDs in the mutation.
func (m *FacilityMutation) WatchConditionsIDs() (ids []string) {
	for id := range m.watch_conditions {
		ids = append(ids, id)
	}
	return
}

// ResetWatchConditions resets all changes to the "watch_conditions" edge.
func (m *FacilityMutation) ResetWatchConditions() {
	m.watch_conditions = nil
	m.clearedwatch_conditions = false
	m.removedwatch_conditions = nil
}

// AddSlotIDs adds the "slots" edge to the Slot entity by ids.
func (m *FacilityMutation) AddSlotIDs(ids ...string) {
	if m.slots == nil {
		m.slots = make(map[string]struct{})
	}
	for i := range ids {
		m.slots[ids[i]] = struct{}{}
	}
}

// ClearSlots clears the "slots" edge to the Slot entity.
func (m *FacilityMutation) ClearSlots() {
	m.clearedslots = true
}

// SlotsCleared reports if the "slots" edge to the Slot entity was cleared.
func (m *FacilityMutation) SlotsCleared() bool {
	return m.clearedslots
}

// RemoveSlotIDs removes the "slots" edge to the Slot entity by IDs.
func (m *FacilityMutation) RemoveSlotIDs(ids ...string) {
	if m.removedslots == nil {
		m.removedslots = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.slots, ids[i])
		m.removedslots[ids[i]] = struct{}{}
	}
}

// RemovedSlots returns the removed IDs of the "slots" edge to the Slot entity.
func (m *FacilityMutation) RemovedSlotsIDs() (ids []string) {
	for id := range m.removedslots {
		ids = append(ids, id)
	}
	return
}

// SlotsIDs returns the "slots" edge IDs in the mutation.
func (m *FacilityMutation) SlotsIDs() (ids []string) {
	for id := range m.slots {
		ids = append(ids, id)
	}
	return
}

// ResetSlots resets all changes to the "slots" edge.
func (m *FacilityMutation) ResetSlots() {
	m.slots = nil
	m.clearedslots = false
	m.removedslots = nil
}

// Where appends a list predicates to the FacilityMutation builder.
func (m *FacilityMutation) Where(ps ...predicate.Facility) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FacilityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FacilityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Facility, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FacilityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FacilityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Facility).
func (m *FacilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FacilityMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, facility.FieldName)
	}
	if m.municipality != nil {
		fields = append(fields, facility.FieldMunicipality)
	}
	if m.scraper_type != nil {
		fields = append(fields, facility.FieldScraperType)
	}
	if m.url != nil {
		fields = append(fields, facility.FieldURL)
	}
	if m.enabled != nil {
		fields = append(fields, facility.FieldEnabled)
	}
	if m.created_at != nil {
		fields = append(fields, facility.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FacilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case facility.FieldName:
		return m.Name()
	case facility.FieldMunicipality:
		return m.Municipality()
	case facility.FieldScraperType:
		return m.ScraperType()
	case facility.FieldURL:
		return m.URL()
	case facility.FieldEnabled:
		return m.Enabled()
	case facility.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FacilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case facility.FieldName:
		return m.OldName(ctx)
	case facility.FieldMunicipality:
		return m.OldMunicipality(ctx)
	case facility.FieldScraperType:
		return m.OldScraperType(ctx)
	case facility.FieldURL:
		return m.OldURL(ctx)
	case facility.FieldEnabled:
		return m.OldEnabled(ctx)
	case facility.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Facility field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FacilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case facility.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case facility.FieldMunicipality:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMunicipality(v)
		return nil
	case facility.FieldScraperType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScraperType(v)
		return nil
	case facility.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case facility.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case facility.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Facility field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FacilityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FacilityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FacilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Facility numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FacilityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FacilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FacilityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Facility nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FacilityMutation) ResetField(name string) error {
	switch name {
	case facility.FieldName:
		m.ResetName()
		return nil
	case facility.FieldMunicipality:
		m.ResetMunicipality()
		return nil
	case facility.FieldScraperType:
		m.ResetScraperType()
		return nil
	case facility.FieldURL:
		m.ResetURL()
		return nil
	case facility.FieldEnabled:
		m.ResetEnabled()
		return nil
	case facility.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Facility field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FacilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.watch_conditions != nil {
		edges = append(edges, facility.EdgeWatchConditions)
	}
	if m.slots != nil {
		edges = append(edges, facility.EdgeSlots)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FacilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case facility.EdgeWatchConditions:
		ids := make([]ent.Value, 0, len(m.watch_conditions))
		for id := range m.watch_conditions {
			ids = append(ids, id)
		}
		return ids
	case facility.EdgeSlots:
		ids := make([]ent.Value, 0, len(m.slots))
		for id := range m.slots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FacilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedwatch_conditions != nil {
		edges = append(edges, facility.EdgeWatchConditions)
	}
	if m.removedslots != nil {
		edges = append(edges, facility.EdgeSlots)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FacilityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case facility.EdgeWatchConditions:
		ids := make([]ent.Value, 0, len(m.removedwatch_conditions))
		for id := range m.removedwatch_conditions {
			ids = append(ids, id)
		}
		return ids
	case facility.EdgeSlots:
		ids := make([]ent.Value, 0, len(m.removedslots))
		for id := range m.removedslots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FacilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedwatch_conditions {
		edges = append(edges, facility.EdgeWatchConditions)
	}
	if m.clearedslots {
		edges = append(edges, facility.EdgeSlots)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FacilityMutation) EdgeCleared(name string) bool {
	switch name {
	case facility.EdgeWatchConditions:
		return m.clearedwatch_conditions
	case facility.EdgeSlots:
		return m.clearedslots
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FacilityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Facility unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FacilityMutation) ResetEdge(name string) error {
	switch name {
	case facility.EdgeWatchConditions:
		m.ResetWatchConditions()
		return nil
	case facility.EdgeSlots:
		m.ResetSlots()
		return nil
	}
	return fmt.Errorf("unknown Facility edge %s", name)
}

// GroundMutation represents an operation that mutates the Ground nodes in the graph.
type GroundMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	name                *string
	court_pattern       *string
	enabled             *bool
	created_at          *time.Time
	clearedFields       map[string]struct{}
	municipality        *string
	clearedmunicipality bool
	slots               map[string]struct{}
	removedslots        map[string]struct{}
	clearedslots        bool
	done                bool
	oldValue            func(context.Context) (*Ground, error)
	predicates          []predicate.Ground
}

var _ ent.Mutation = (*GroundMutation)(nil)

// groundOption allows management of the mutation configuration using functional options.
type groundOption func(*GroundMutation)

// newGroundMutation creates new mutation for the Ground entity.
func newGroundMutation(c config, op Op, opts ...groundOption) *GroundMutation {
	m := &GroundMutation{
		config:        c,
		op:            op,
		typ:           TypeGround,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroundID sets the ID field of the mutation.
func withGroundID(id string) groundOption {
	return func(m *GroundMutation) {
		var (
			err   error
			once  sync.Once
			value *Ground
		)
		m.oldValue = func(ctx context.Context) (*Ground, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ground.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGround sets the old Ground of the mutation.
func withGround(node *Ground) groundOption {
	return func(m *GroundMutation) {
		m.oldValue = func(context.Context) (*Ground, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ground entities.
func (m *GroundMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroundMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroundMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ground.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *GroundMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroundMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Ground entity.
// If the Ground object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroundMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroundMutation) ResetName() {
	m.name = nil
}

// SetCourtPattern sets the "court_pattern" field.
func (m *GroundMutation) SetCourtPattern(s string) {
	m.court_pattern = &s
}

// CourtPattern returns the value of the "court_pattern" field in the mutation.
func (m *GroundMutation) CourtPattern() (r string, exists bool) {
	v := m.court_pattern
	if v == nil {
		return
	}
	return *v, true
}

// OldCourtPattern returns the old "court_pattern" field's value of the Ground entity.
// If the Ground object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroundMutation) OldCourtPattern(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourtPattern is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourtPattern requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourtPattern: %w", err)
	}
	return oldValue.CourtPattern, nil
}

// ClearCourtPattern clears the value of the "court_pattern" field.
func (m *GroundMutation) ClearCourtPattern() {
	m.court_pattern = nil
	m.clearedFields[ground.FieldCourtPattern] = struct{}{}
}

// CourtPatternCleared returns if the "court_pattern" field was cleared in this mutation.
func (m *GroundMutation) CourtPatternCleared() bool {
	_, ok := m.clearedFields[ground.FieldCourtPattern]
	return ok
}

// ResetCourtPattern resets all changes to the "court_pattern" field.
func (m *GroundMutation) ResetCourtPattern() {
	m.court_pattern = nil
	delete(m.clearedFields, ground.FieldCourtPattern)
}

// SetEnabled sets the "enabled" field.
func (m *GroundMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *GroundMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Ground entity.
// If the Ground object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroundMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *GroundMutation) ResetEnabled() {
	m.enabled = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GroundMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroundMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ground entity.
// If the Ground object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroundMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroundMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetMunicipalityID sets the "municipality" edge to the Municipality entity by id.
func (m *GroundMutation) SetMunicipalityID(id string) {
	m.municipality = &id
}

// ClearMunicipality clears the "municipality" edge to the Municipality entity.
func (m *GroundMutation) ClearMunicipality() {
	m.clearedmunicipality = true
}

// MunicipalityCleared reports if the "municipality" edge to the Municipality entity was cleared.
func (m *GroundMutation) MunicipalityCleared() bool {
	return m.clearedmunicipality
}

// MunicipalityID returns the "municipality" edge ID in the mutation.
func (m *GroundMutation) MunicipalityID() (id string, exists bool) {
	if m.municipality != nil {
		return *m.municipality, true
	}
	return
}

// MunicipalityIDs returns the "municipality" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MunicipalityID instead. It exists only for internal usage by the builders.
func (m *GroundMutation) MunicipalityIDs() (ids []string) {
	if id := m.municipality; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMunicipality resets all changes to the "municipality" edge.
func (m *GroundMutation) ResetMunicipality() {
	m.municipality = nil
	m.clearedmunicipality = false
}

// AddSlotIDs adds the "slots" edge to the Slot entity by ids.
func (m *GroundMutation) AddSlotIDs(ids ...string) {
	if m.slots == nil {
		m.slots = make(map[string]struct{})
	}
	for i := range ids {
		m.slots[ids[i]] = struct{}{}
	}
}

// ClearSlots clears the "slots" edge to the Slot entity.
func (m *GroundMutation) ClearSlots() {
	m.clearedslots = true
}

// SlotsCleared reports if the "slots" edge to the Slot entity was cleared.
func (m *GroundMutation) SlotsCleared() bool {
	return m.clearedslots
}

// RemoveSlotIDs removes the "slots" edge to the Slot entity by IDs.
func (m *GroundMutation) RemoveSlotIDs(ids ...string) {
	if m.removedslots == nil {
		m.removedslots = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.slots, ids[i])
		m.removedslots[ids[i]] = struct{}{}
	}
}

// RemovedSlots returns the removed IDs of the "slots" edge to the Slot entity.
func (m *GroundMutation) RemovedSlotsIDs() (ids []string) {
	for id := range m.removedslots {
		ids = append(ids, id)
	}
	return
}

// SlotsIDs returns the "slots" edge IDs in the mutation.
func (m *GroundMutation) SlotsIDs() (ids []string) {
	for id := range m.slots {
		ids = append(ids, id)
	}
	return
}

// ResetSlots resets all changes to the "slots" edge.
func (m *GroundMutation) ResetSlots() {
	m.slots = nil
	m.clearedslots = false
	m.removedslots = nil
}

// Where appends a list predicates to the GroundMutation builder.
func (m *GroundMutation) Where(ps ...predicate.Ground) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroundMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroundMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ground, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroundMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroundMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ground).
func (m *GroundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroundMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, ground.FieldName)
	}
	if m.court_pattern != nil {
		fields = append(fields, ground.FieldCourtPattern)
	}
	if m.enabled != nil {
		fields = append(fields, ground.FieldEnabled)
	}
	if m.created_at != nil {
		fields = append(fields, ground.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ground.FieldName:
		return m.Name()
	case ground.FieldCourtPattern:
		return m.CourtPattern()
	case ground.FieldEnabled:
		return m.Enabled()
	case ground.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ground.FieldName:
		return m.OldName(ctx)
	case ground.FieldCourtPattern:
		return m.OldCourtPattern(ctx)
	case ground.FieldEnabled:
		return m.OldEnabled(ctx)
	case ground.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Ground field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ground.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ground.FieldCourtPattern:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourtPattern(v)
		return nil
	case ground.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case ground.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Ground field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroundMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroundMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroundMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ground numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroundMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ground.FieldCourtPattern) {
		fields = append(fields, ground.FieldCourtPattern)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroundMutation) ClearField(name string) error {
	switch name {
	case ground.FieldCourtPattern:
		m.ClearCourtPattern()
		return nil
	}
	return fmt.Errorf("unknown Ground nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroundMutation) ResetField(name string) error {
	switch name {
	case ground.FieldName:
		m.ResetName()
		return nil
	case ground.FieldCourtPattern:
		m.ResetCourtPattern()
		return nil
	case ground.FieldEnabled:
		m.ResetEnabled()
		return nil
	case ground.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Ground field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroundMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.municipality != nil {
		edges = append(edges, ground.EdgeMunicipality)
	}
	if m.slots != nil {
		edges = append(edges, ground.EdgeSlots)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroundMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ground.EdgeMunicipality:
		if id := m.municipality; id != nil {
			return []ent.Value{*id}
		}
	case ground.EdgeSlots:
		ids := make([]ent.Value, 0, len(m.slots))
		for id := range m.slots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedslots != nil {
		edges = append(edges, ground.EdgeSlots)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroundMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ground.EdgeSlots:
		ids := make([]ent.Value, 0, len(m.removedslots))
		for id := range m.removedslots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmunicipality {
		edges = append(edges, ground.EdgeMunicipality)
	}
	if m.clearedslots {
		edges = append(edges, ground.EdgeSlots)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroundMutation) EdgeCleared(name string) bool {
	switch name {
	case ground.EdgeMunicipality:
		return m.clearedmunicipality
	case ground.EdgeSlots:
		return m.clearedslots
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroundMutation) ClearEdge(name string) error {
	switch name {
	case ground.EdgeMunicipality:
		m.ClearMunicipality()
		return nil
	}
	return fmt.Errorf("unknown Ground unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroundMutation) ResetEdge(name string) error {
	switch name {
	case ground.EdgeMunicipality:
		m.ResetMunicipality()
		return nil
	case ground.EdgeSlots:
		m.ResetSlots()
		return nil
	}
	return fmt.Errorf("unknown Ground edge %s", name)
}

// MunicipalityMutation represents an operation that mutates the Municipality nodes in the graph.
type MunicipalityMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	name               *string
	scraper_type       *string
	url                *string
	enabled            *bool
	created_at         *time.Time
	clearedFields      map[string]struct{}
	grounds            map[string]struct{}
	removedgrounds     map[string]struct{}
	clearedgrounds     bool
	slots              map[string]struct{}
	removedslots       map[string]struct{}
	clearedslots       bool
	scrape_jobs        map[string]struct{}
	removedscrape_jobs map[string]struct{}
	clearedscrape_jobs bool
	done               bool
	oldValue           func(context.Context) (*Municipality, error)
	predicates         []predicate.Municipality
}

var _ ent.Mutation = (*MunicipalityMutation)(nil)

// municipalityOption allows management of the mutation configuration using functional options.
type municipalityOption func(*MunicipalityMutation)

// newMunicipalityMutation creates new mutation for the Municipality entity.
func newMunicipalityMutation(c config, op Op, opts ...municipalityOption) *MunicipalityMutation {
	m := &MunicipalityMutation{
		config:        c,
		op:            op,
		typ:           TypeMunicipality,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMunicipalityID sets the ID field of the mutation.
func withMunicipalityID(id string) municipalityOption {
	return func(m *MunicipalityMutation) {
		var (
			err   error
			once  sync.Once
			value *Municipality
		)
		m.oldValue = func(ctx context.Context) (*Municipality, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Municipality.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMunicipality sets the old Municipality of the mutation.
func withMunicipality(node *Municipality) municipalityOption {
	return func(m *MunicipalityMutation) {
		m.oldValue = func(context.Context) (*Municipality, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MunicipalityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MunicipalityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Municipality entities.
func (m *MunicipalityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MunicipalityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MunicipalityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Municipality.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MunicipalityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MunicipalityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Municipality entity.
// If the Municipality object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MunicipalityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MunicipalityMutation) ResetName() {
	m.name = nil
}

// SetScraperType sets the "scraper_type" field.
func (m *MunicipalityMutation) SetScraperType(s string) {
	m.scraper_type = &s
}

// ScraperType returns the value of the "scraper_type" field in the mutation.
func (m *MunicipalityMutation) ScraperType() (r string, exists bool) {
	v := m.scraper_type
	if v == nil {
		return
	}
	return *v, true
}

// OldScraperType returns the old "scraper_type" field's value of the Municipality entity.
// If the Municipality object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MunicipalityMutation) OldScraperType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScraperType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScraperType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScraperType: %w", err)
	}
	return oldValue.ScraperType, nil
}

// ResetScraperType resets all changes to the "scraper_type" field.
func (m *MunicipalityMutation) ResetScraperType() {
	m.scraper_type = nil
}

// SetURL sets the "url" field.
func (m *MunicipalityMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *MunicipalityMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Municipality entity.
// If the Municipality object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MunicipalityMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *MunicipalityMutation) ResetURL() {
	m.url = nil
}

// SetEnabled sets the "enabled" field.
func (m *MunicipalityMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *MunicipalityMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Municipality entity.
// If the Municipality object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MunicipalityMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *MunicipalityMutation) ResetEnabled() {
	m.enabled = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MunicipalityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MunicipalityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Municipality entity.
// If the Municipality object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MunicipalityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MunicipalityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddGroundIDs adds the "grounds" edge to the Ground entity by ids.
func (m *MunicipalityMutation) AddGroundIDs(ids ...string) {
	if m.grounds == nil {
		m.grounds = make(map[string]struct{})
	}
	for i := range ids {
		m.grounds[ids[i]] = struct{}{}
	}
}

// ClearGrounds clears the "grounds" edge to the Ground entity.
func (m *MunicipalityMutation) ClearGrounds() {
	m.clearedgrounds = true
}

// GroundsCleared reports if the "grounds" edge to the Ground entity was cleared.
func (m *MunicipalityMutation) GroundsCleared() bool {
	return m.clearedgrounds
}

// RemoveGroundIDs removes the "grounds" edge to the Ground entity by IDs.
func (m *MunicipalityMutation) RemoveGroundIDs(ids ...string) {
	if m.removedgrounds == nil {
		m.removedgrounds = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.grounds, ids[i])
		m.removedgrounds[ids[i]] = struct{}{}
	}
}

// RemovedGrounds returns the removed IDs of the "grounds" edge to the Ground entity.
func (m *MunicipalityMutation) RemovedGroundsIDs() (ids []string) {
	for id := range m.removedgrounds {
		ids = append(ids, id)
	}
	return
}

// GroundsIDs returns the "grounds" edge IDs in the mutation.
func (m *MunicipalityMutation) GroundsIDs() (ids []string) {
	for id := range m.grounds {
		ids = append(ids, id)
	}
	return
}

// ResetGrounds resets all changes to the "grounds" edge.
func (m *MunicipalityMutation) ResetGrounds() {
	m.grounds = nil
	m.clearedgrounds = false
	m.removedgrounds = nil
}

// AddSlotIDs adds the "slots" edge to the Slot entity by ids.
func (m *MunicipalityMutation) AddSlotIDs(ids ...string) {
	if m.slots == nil {
		m.slots = make(map[string]struct{})
	}
	for i := range ids {
		m.slots[ids[i]] = struct{}{}
	}
}

// ClearSlots clears the "slots" edge to the Slot entity.
func (m *MunicipalityMutation) ClearSlots() {
	m.clearedslots = true
}

// SlotsCleared reports if the "slots" edge to the Slot entity was cleared.
func (m *MunicipalityMutation) SlotsCleared() bool {
	return m.clearedslots
}

// RemoveSlotIDs removes the "slots" edge to the Slot entity by IDs.
func (m *MunicipalityMutation) RemoveSlotIDs(ids ...string) {
	if m.removedslots == nil {
		m.removedslots = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.slots, ids[i])
		m.removedslots[ids[i]] = struct{}{}
	}
}

// RemovedSlots returns the removed IDs of the "slots" edge to the Slot entity.
func (m *MunicipalityMutation) RemovedSlotsIDs() (ids []string) {
	for id := range m.removedslots {
		ids = append(ids, id)
	}
	return
}

// SlotsIDs returns the "slots" edge IDs in the mutation.
func (m *MunicipalityMutation) SlotsIDs() (ids []string) {
	for id := range m.slots {
		ids = append(ids, id)
	}
	return
}

// ResetSlots resets all changes to the "slots" edge.
func (m *MunicipalityMutation) ResetSlots() {
	m.slots = nil
	m.clearedslots = false
	m.removedslots = nil
}

// AddScrapeJobIDs adds the "scrape_jobs" edge to the ScrapeJob entity by ids.
func (m *MunicipalityMutation) AddScrapeJobIDs(ids ...string) {
	if m.scrape_jobs == nil {
		m.scrape_jobs = make(map[string]struct{})
	}
	for i := range ids {
		m.scrape_jobs[ids[i]] = struct{}{}
	}
}

// ClearScrapeJobs clears the "scrape_jobs" edge to the ScrapeJob entity.
func (m *MunicipalityMutation) ClearScrapeJobs() {
	m.clearedscrape_jobs = true
}

// ScrapeJobsCleared reports if the "scrape_jobs" edge to the ScrapeJob entity was cleared.
func (m *MunicipalityMutation) ScrapeJobsCleared() bool {
	return m.clearedscrape_jobs
}

// RemoveScrapeJobIDs removes the "scrape_jobs" edge to the ScrapeJob entity by IDs.
func (m *MunicipalityMutation) RemoveScrapeJobIDs(ids ...string) {
	if m.removedscrape_jobs == nil {
		m.removedscrape_jobs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.scrape_jobs, ids[i])
		m.removedscrape_jobs[ids[i]] = struct{}{}
	}
}

// RemovedScrapeJobs returns the removed IDs of the "scrape_jobs" edge to the ScrapeJob entity.
func (m *MunicipalityMutation) RemovedScrapeJobsIDs() (ids []string) {
	for id := range m.removedscrape_jobs {
		ids = append(ids, id)
	}
	return
}

// ScrapeJobsIDs returns the "scrape_jobs" edge IDs in the mutation.
func (m *MunicipalityMutation) ScrapeJobsIDs() (ids []string) {
	for id := range m.scrape_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetScrapeJobs resets all changes to the "scrape_jobs" edge.
func (m *MunicipalityMutation) ResetScrapeJobs() {
	m.scrape_jobs = nil
	m.clearedscrape_jobs = false
	m.removedscrape_jobs = nil
}

// Where appends a list predicates to the MunicipalityMutation builder.
func (m *MunicipalityMutation) Where(ps ...predicate.Municipality) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MunicipalityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MunicipalityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Municipality, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MunicipalityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MunicipalityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Municipality).
func (m *MunicipalityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MunicipalityMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, municipality.FieldName)
	}
	if m.scraper_type != nil {
		fields = append(fields, municipality.FieldScraperType)
	}
	if m.url != nil {
		fields = append(fields, municipality.FieldURL)
	}
	if m.enabled != nil {
		fields = append(fields, municipality.FieldEnabled)
	}
	if m.created_at != nil {
		fields = append(fields, municipality.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MunicipalityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case municipality.FieldName:
		return m.Name()
	case municipality.FieldScraperType:
		return m.ScraperType()
	case municipality.FieldURL:
		return m.URL()
	case municipality.FieldEnabled:
		return m.Enabled()
	case municipality.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MunicipalityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case municipality.FieldName:
		return m.OldName(ctx)
	case municipality.FieldScraperType:
		return m.OldScraperType(ctx)
	case municipality.FieldURL:
		return m.OldURL(ctx)
	case municipality.FieldEnabled:
		return m.OldEnabled(ctx)
	case municipality.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Municipality field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MunicipalityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case municipality.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case municipality.FieldScraperType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScraperType(v)
		return nil
	case municipality.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case municipality.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case municipality.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Municipality field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MunicipalityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MunicipalityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MunicipalityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Municipality numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MunicipalityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MunicipalityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MunicipalityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Municipality nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MunicipalityMutation) ResetField(name string) error {
	switch name {
	case municipality.FieldName:
		m.ResetName()
		return nil
	case municipality.FieldScraperType:
		m.ResetScraperType()
		return nil
	case municipality.FieldURL:
		m.ResetURL()
		return nil
	case municipality.FieldEnabled:
		m.ResetEnabled()
		return nil
	case municipality.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Municipality field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MunicipalityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.grounds != nil {
		edges = append(edges, municipality.EdgeGrounds)
	}
	if m.slots != nil {
		edges = append(edges, municipality.EdgeSlots)
	}
	if m.scrape_jobs != nil {
		edges = append(edges, municipality.EdgeScrapeJobs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MunicipalityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case municipality.EdgeGrounds:
		ids := make([]ent.Value, 0, len(m.grounds))
		for id := range m.grounds {
			ids = append(ids, id)
		}
		return ids
	case municipality.EdgeSlots:
		ids := make([]ent.Value, 0, len(m.slots))
		for id := range m.slots {
			ids = append(ids, id)
		}
		return ids
	case municipality.EdgeScrapeJobs:
		ids := make([]ent.Value, 0, len(m.scrape_jobs))
		for id := range m.scrape_jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MunicipalityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedgrounds != nil {
		edges = append(edges, municipality.EdgeGrounds)
	}
	if m.removedslots != nil {
		edges = append(edges, municipality.EdgeSlots)
	}
	if m.removedscrape_jobs != nil {
		edges = append(edges, municipality.EdgeScrapeJobs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MunicipalityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case municipality.EdgeGrounds:
		ids := make([]ent.Value, 0, len(m.removedgrounds))
		for id := range m.removedgrounds {
			ids = append(ids, id)
		}
		return ids
	case municipality.EdgeSlots:
		ids := make([]ent.Value, 0, len(m.removedslots))
		for id := range m.removedslots {
			ids = append(ids, id)
		}
		return ids
	case municipality.EdgeScrapeJobs:
		ids := make([]ent.Value, 0, len(m.removedscrape_jobs))
		for id := range m.removedscrape_jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MunicipalityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedgrounds {
		edges = append(edges, municipality.EdgeGrounds)
	}
	if m.clearedslots {
		edges = append(edges, municipality.EdgeSlots)
	}
	if m.clearedscrape_jobs {
		edges = append(edges, municipality.EdgeScrapeJobs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MunicipalityMutation) EdgeCleared(name string) bool {
	switch name {
	case municipality.EdgeGrounds:
		return m.clearedgrounds
	case municipality.EdgeSlots:
		return m.clearedslots
	case municipality.EdgeScrapeJobs:
		return m.clearedscrape_jobs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MunicipalityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Municipality unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MunicipalityMutation) ResetEdge(name string) error {
	switch name {
	case municipality.EdgeGrounds:
		m.ResetGrounds()
		return nil
	case municipality.EdgeSlots:
		m.ResetSlots()
		return nil
	case municipality.EdgeScrapeJobs:
		m.ResetScrapeJobs()
		return nil
	}
	return fmt.Errorf("unknown Municipality edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	channel                *string
	status                 *notification.Status
	sent_at                *time.Time
	created_at             *time.Time
	clearedFields          map[string]struct{}
	team                   *string
	clearedteam            bool
	watch_condition        *string
	clearedwatch_condition bool
	slot                   *string
	clearedslot            bool
	done                   bool
	oldValue               func(context.Context) (*Notification, error)
	predicates             []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id string) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notification entities.
func (m *NotificationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChannel sets the "channel" field.
func (m *NotificationMutation) SetChannel(s string) {
	m.channel = &s
}

// Channel returns the value of the "channel" field in the mutation.
func (m *NotificationMutation) Channel() (r string, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *NotificationMutation) ResetChannel() {
	m.channel = nil
}

// SetStatus sets the "status" field.
func (m *NotificationMutation) SetStatus(n notification.Status) {
	m.status = &n
}

// Status returns the value of the "status" field in the mutation.
func (m *NotificationMutation) Status() (r notification.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldStatus(ctx context.Context) (v notification.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NotificationMutation) ResetStatus() {
	m.status = nil
}

// SetSentAt sets the "sent_at" field.
func (m *NotificationMutation) SetSentAt(t time.Time) {
	m.sent_at = &t
}

// SentAt returns the value of the "sent_at" field in the mutation.
func (m *NotificationMutation) SentAt() (r time.Time, exists bool) {
	v := m.sent_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSentAt returns the old "sent_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldSentAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentAt: %w", err)
	}
	return oldValue.SentAt, nil
}

// ClearSentAt clears the value of the "sent_at" field.
func (m *NotificationMutation) ClearSentAt() {
	m.sent_at = nil
	m.clearedFields[notification.FieldSentAt] = struct{}{}
}

// SentAtCleared returns if the "sent_at" field was cleared in this mutation.
func (m *NotificationMutation) SentAtCleared() bool {
	_, ok := m.clearedFields[notification.FieldSentAt]
	return ok
}

// ResetSentAt resets all changes to the "sent_at" field.
func (m *NotificationMutation) ResetSentAt() {
	m.sent_at = nil
	delete(m.clearedFields, notification.FieldSentAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *NotificationMutation) SetTeamID(id string) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *NotificationMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *NotificationMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *NotificationMutation) TeamID() (id string, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) TeamIDs() (ids []string) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *NotificationMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// SetWatchConditionID sets the "watch_condition" edge to the WatchCondition entity by id.
func (m *NotificationMutation) SetWatchConditionID(id string) {
	m.watch_condition = &id
}

// ClearWatchCondition clears the "watch_condition" edge to the WatchCondition entity.
func (m *NotificationMutation) ClearWatchCondition() {
	m.clearedwatch_condition = true
}

// WatchConditionCleared reports if the "watch_condition" edge to the WatchCondition entity was cleared.
func (m *NotificationMutation) WatchConditionCleared() bool {
	return m.clearedwatch_condition
}

// WatchConditionID returns the "watch_condition" edge ID in the mutation.
func (m *NotificationMutation) WatchConditionID() (id string, exists bool) {
	if m.watch_condition != nil {
		return *m.watch_condition, true
	}
	return
}

// WatchConditionIDs returns the "watch_condition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WatchConditionID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) WatchConditionIDs() (ids []string) {
	if id := m.watch_condition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWatchCondition resets all changes to the "watch_condition" edge.
func (m *NotificationMutation) ResetWatchCondition() {
	m.watch_condition = nil
	m.clearedwatch_condition = false
}

// SetSlotID sets the "slot" edge to the Slot entity by id.
func (m *NotificationMutation) SetSlotID(id string) {
	m.slot = &id
}

// ClearSlot clears the "slot" edge to the Slot entity.
func (m *NotificationMutation) ClearSlot() {
	m.clearedslot = true
}

// SlotCleared reports if the "slot" edge to the Slot entity was cleared.
func (m *NotificationMutation) SlotCleared() bool {
	return m.clearedslot
}

// SlotID returns the "slot" edge ID in the mutation.
func (m *NotificationMutation) SlotID() (id string, exists bool) {
	if m.slot != nil {
		return *m.slot, true
	}
	return
}

// SlotIDs returns the "slot" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SlotID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) SlotIDs() (ids []string) {
	if id := m.slot; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSlot resets all changes to the "slot" edge.
func (m *NotificationMutation) ResetSlot() {
	m.slot = nil
	m.clearedslot = false
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.channel != nil {
		fields = append(fields, notification.FieldChannel)
	}
	if m.status != nil {
		fields = append(fields, notification.FieldStatus)
	}
	if m.sent_at != nil {
		fields = append(fields, notification.FieldSentAt)
	}
	if m.created_at != nil {
		fields = append(fields, notification.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldChannel:
		return m.Channel()
	case notification.FieldStatus:
		return m.Status()
	case notification.FieldSentAt:
		return m.SentAt()
	case notification.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldChannel:
		return m.OldChannel(ctx)
	case notification.FieldStatus:
		return m.OldStatus(ctx)
	case notification.FieldSentAt:
		return m.OldSentAt(ctx)
	case notification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case notification.FieldStatus:
		v, ok := value.(notification.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case notification.FieldSentAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentAt(v)
		return nil
	case notification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldSentAt) {
		fields = append(fields, notification.FieldSentAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldSentAt:
		m.ClearSentAt()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldChannel:
		m.ResetChannel()
		return nil
	case notification.FieldStatus:
		m.ResetStatus()
		return nil
	case notification.FieldSentAt:
		m.ResetSentAt()
		return nil
	case notification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.team != nil {
		edges = append(edges, notification.EdgeTeam)
	}
	if m.watch_condition != nil {
		edges = append(edges, notification.EdgeWatchCondition)
	}
	if m.slot != nil {
		edges = append(edges, notification.EdgeSlot)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case notification.EdgeWatchCondition:
		if id := m.watch_condition; id != nil {
			return []ent.Value{*id}
		}
	case notification.EdgeSlot:
		if id := m.slot; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedteam {
		edges = append(edges, notification.EdgeTeam)
	}
	if m.clearedwatch_condition {
		edges = append(edges, notification.EdgeWatchCondition)
	}
	if m.clearedslot {
		edges = append(edges, notification.EdgeSlot)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	switch name {
	case notification.EdgeTeam:
		return m.clearedteam
	case notification.EdgeWatchCondition:
		return m.clearedwatch_condition
	case notification.EdgeSlot:
		return m.clearedslot
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	switch name {
	case notification.EdgeTeam:
		m.ClearTeam()
		return nil
	case notification.EdgeWatchCondition:
		m.ClearWatchCondition()
		return nil
	case notification.EdgeSlot:
		m.ClearSlot()
		return nil
	}
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	switch name {
	case notification.EdgeTeam:
		m.ResetTeam()
		return nil
	case notification.EdgeWatchCondition:
		m.ResetWatchCondition()
		return nil
	case notification.EdgeSlot:
		m.ResetSlot()
		return nil
	}
	return fmt.Errorf("unknown Notification edge %s", name)
}

// PromoCodeMutation represents an operation that mutates the PromoCode nodes in the graph.
type PromoCodeMutation struct {
	config
	op                Op
	typ               string
	id                *string
	code              *string
	discount_type     *promocode.DiscountType
	discount_value    *int
	adddiscount_value *int
	applies_to        *string
	valid_from        *time.Time
	valid_until       *time.Time
	max_uses          *int
	addmax_uses       *int
	uses_count        *int
	adduses_count     *int
	enabled           *bool
	created_at        *time.Time
	clearedFields     map[string]struct{}
	usages            map[string]struct{}
	removedusages     map[string]struct{}
	clearedusages     bool
	done              bool
	oldValue          func(context.Context) (*PromoCode, error)
	predicates        []predicate.PromoCode
}

var _ ent.Mutation = (*PromoCodeMutation)(nil)

// promocodeOption allows management of the mutation configuration using functional options.
type promocodeOption func(*PromoCodeMutation)

// newPromoCodeMutation creates new mutation for the PromoCode entity.
func newPromoCodeMutation(c config, op Op, opts ...promocodeOption) *PromoCodeMutation {
	m := &PromoCodeMutation{
		config:        c,
		op:            op,
		typ:           TypePromoCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromoCodeID sets the ID field of the mutation.
func withPromoCodeID(id string) promocodeOption {
	return func(m *PromoCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *PromoCode
		)
		m.oldValue = func(ctx context.Context) (*PromoCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromoCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromoCode sets the old PromoCode of the mutation.
func withPromoCode(node *PromoCode) promocodeOption {
	return func(m *PromoCodeMutation) {
		m.oldValue = func(context.Context) (*PromoCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromoCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromoCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PromoCode entities.
func (m *PromoCodeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromoCodeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromoCodeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromoCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *PromoCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *PromoCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *PromoCodeMutation) ResetCode() {
	m.code = nil
}

// SetDiscountType sets the "discount_type" field.
func (m *PromoCodeMutation) SetDiscountType(pt promocode.DiscountType) {
	m.discount_type = &pt
}

// DiscountType returns the value of the "discount_type" field in the mutation.
func (m *PromoCodeMutation) DiscountType() (r promocode.DiscountType, exists bool) {
	v := m.discount_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountType returns the old "discount_type" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldDiscountType(ctx context.Context) (v promocode.DiscountType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountType: %w", err)
	}
	return oldValue.DiscountType, nil
}

// ResetDiscountType resets all changes to the "discount_type" field.
func (m *PromoCodeMutation) ResetDiscountType() {
	m.discount_type = nil
}

// SetDiscountValue sets the "discount_value" field.
func (m *PromoCodeMutation) SetDiscountValue(i int) {
	m.discount_value = &i
	m.adddiscount_value = nil
}

// DiscountValue returns the value of the "discount_value" field in the mutation.
func (m *PromoCodeMutation) DiscountValue() (r int, exists bool) {
	v := m.discount_value
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountValue returns the old "discount_value" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldDiscountValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountValue: %w", err)
	}
	return oldValue.DiscountValue, nil
}

// AddDiscountValue adds i to the "discount_value" field.
func (m *PromoCodeMutation) AddDiscountValue(i int) {
	if m.adddiscount_value != nil {
		*m.adddiscount_value += i
	} else {
		m.adddiscount_value = &i
	}
}

// AddedDiscountValue returns the value that was added to the "discount_value" field in this mutation.
func (m *PromoCodeMutation) AddedDiscountValue() (r int, exists bool) {
	v := m.adddiscount_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscountValue resets all changes to the "discount_value" field.
func (m *PromoCodeMutation) ResetDiscountValue() {
	m.discount_value = nil
	m.adddiscount_value = nil
}

// SetAppliesTo sets the "applies_to" field.
func (m *PromoCodeMutation) SetAppliesTo(s string) {
	m.applies_to = &s
}

// AppliesTo returns the value of the "applies_to" field in the mutation.
func (m *PromoCodeMutation) AppliesTo() (r string, exists bool) {
	v := m.applies_to
	if v == nil {
		return
	}
	return *v, true
}

// OldAppliesTo returns the old "applies_to" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldAppliesTo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppliesTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppliesTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppliesTo: %w", err)
	}
	return oldValue.AppliesTo, nil
}

// ClearAppliesTo clears the value of the "applies_to" field.
func (m *PromoCodeMutation) ClearAppliesTo() {
	m.applies_to = nil
	m.clearedFields[promocode.FieldAppliesTo] = struct{}{}
}

// AppliesToCleared returns if the "applies_to" field was cleared in this mutation.
func (m *PromoCodeMutation) AppliesToCleared() bool {
	_, ok := m.clearedFields[promocode.FieldAppliesTo]
	return ok
}

// ResetAppliesTo resets all changes to the "applies_to" field.
func (m *PromoCodeMutation) ResetAppliesTo() {
	m.applies_to = nil
	delete(m.clearedFields, promocode.FieldAppliesTo)
}

// SetValidFrom sets the "valid_from" field.
func (m *PromoCodeMutation) SetValidFrom(t time.Time) {
	m.valid_from = &t
}

// ValidFrom returns the value of the "valid_from" field in the mutation.
func (m *PromoCodeMutation) ValidFrom() (r time.Time, exists bool) {
	v := m.valid_from
	if v == nil {
		return
	}
	return *v, true
}

// OldValidFrom returns the old "valid_from" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldValidFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidFrom: %w", err)
	}
	return oldValue.ValidFrom, nil
}

// ResetValidFrom resets all changes to the "valid_from" field.
func (m *PromoCodeMutation) ResetValidFrom() {
	m.valid_from = nil
}

// SetValidUntil sets the "valid_until" field.
func (m *PromoCodeMutation) SetValidUntil(t time.Time) {
	m.valid_until = &t
}

// ValidUntil returns the value of the "valid_until" field in the mutation.
func (m *PromoCodeMutation) ValidUntil() (r time.Time, exists bool) {
	v := m.valid_until
	if v == nil {
		return
	}
	return *v, true
}

// OldValidUntil returns the old "valid_until" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldValidUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidUntil: %w", err)
	}
	return oldValue.ValidUntil, nil
}

// ClearValidUntil clears the value of the "valid_until" field.
func (m *PromoCodeMutation) ClearValidUntil() {
	m.valid_until = nil
	m.clearedFields[promocode.FieldValidUntil] = struct{}{}
}

// ValidUntilCleared returns if the "valid_until" field was cleared in this mutation.
func (m *PromoCodeMutation) ValidUntilCleared() bool {
	_, ok := m.clearedFields[promocode.FieldValidUntil]
	return ok
}

// ResetValidUntil resets all changes to the "valid_until" field.
func (m *PromoCodeMutation) ResetValidUntil() {
	m.valid_until = nil
	delete(m.clearedFields, promocode.FieldValidUntil)
}

// SetMaxUses sets the "max_uses" field.
func (m *PromoCodeMutation) SetMaxUses(i int) {
	m.max_uses = &i
	m.addmax_uses = nil
}

// MaxUses returns the value of the "max_uses" field in the mutation.
func (m *PromoCodeMutation) MaxUses() (r int, exists bool) {
	v := m.max_uses
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxUses returns the old "max_uses" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldMaxUses(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxUses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxUses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxUses: %w", err)
	}
	return oldValue.MaxUses, nil
}

// AddMaxUses adds i to the "max_uses" field.
func (m *PromoCodeMutation) AddMaxUses(i int) {
	if m.addmax_uses != nil {
		*m.addmax_uses += i
	} else {
		m.addmax_uses = &i
	}
}

// AddedMaxUses returns the value that was added to the "max_uses" field in this mutation.
func (m *PromoCodeMutation) AddedMaxUses() (r int, exists bool) {
	v := m.addmax_uses
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxUses clears the value of the "max_uses" field.
func (m *PromoCodeMutation) ClearMaxUses() {
	m.max_uses = nil
	m.addmax_uses = nil
	m.clearedFields[promocode.FieldMaxUses] = struct{}{}
}

// MaxUsesCleared returns if the "max_uses" field was cleared in this mutation.
func (m *PromoCodeMutation) MaxUsesCleared() bool {
	_, ok := m.clearedFields[promocode.FieldMaxUses]
	return ok
}

// ResetMaxUses resets all changes to the "max_uses" field.
func (m *PromoCodeMutation) ResetMaxUses() {
	m.max_uses = nil
	m.addmax_uses = nil
	delete(m.clearedFields, promocode.FieldMaxUses)
}

// SetUsesCount sets the "uses_count" field.
func (m *PromoCodeMutation) SetUsesCount(i int) {
	m.uses_count = &i
	m.adduses_count = nil
}

// UsesCount returns the value of the "uses_count" field in the mutation.
func (m *PromoCodeMutation) UsesCount() (r int, exists bool) {
	v := m.uses_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsesCount returns the old "uses_count" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldUsesCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsesCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsesCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsesCount: %w", err)
	}
	return oldValue.UsesCount, nil
}

// AddUsesCount adds i to the "uses_count" field.
func (m *PromoCodeMutation) AddUsesCount(i int) {
	if m.adduses_count != nil {
		*m.adduses_count += i
	} else {
		m.adduses_count = &i
	}
}

// AddedUsesCount returns the value that was added to the "uses_count" field in this mutation.
func (m *PromoCodeMutation) AddedUsesCount() (r int, exists bool) {
	v := m.adduses_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsesCount resets all changes to the "uses_count" field.
func (m *PromoCodeMutation) ResetUsesCount() {
	m.uses_count = nil
	m.adduses_count = nil
}

// SetEnabled sets the "enabled" field.
func (m *PromoCodeMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *PromoCodeMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *PromoCodeMutation) ResetEnabled() {
	m.enabled = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PromoCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromoCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromoCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddUsageIDs adds the "usages" edge to the PromoCodeUsage entity by ids.
func (m *PromoCodeMutation) AddUsageIDs(ids ...string) {
	if m.usages == nil {
		m.usages = make(map[string]struct{})
	}
	for i := range ids {
		m.usages[ids[i]] = struct{}{}
	}
}

// ClearUsages clears the "usages" edge to the PromoCodeUsage entity.
func (m *PromoCodeMutation) ClearUsages() {
	m.clearedusages = true
}

// UsagesCleared reports if the "usages" edge to the PromoCodeUsage entity was cleared.
func (m *PromoCodeMutation) UsagesCleared() bool {
	return m.clearedusages
}

// RemoveUsageIDs removes the "usages" edge to the PromoCodeUsage entity by IDs.
func (m *PromoCodeMutation) RemoveUsageIDs(ids ...string) {
	if m.removedusages == nil {
		m.removedusages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.usages, ids[i])
		m.removedusages[ids[i]] = struct{}{}
	}
}

// RemovedUsages returns the removed IDs of the "usages" edge to the PromoCodeUsage entity.
func (m *PromoCodeMutation) RemovedUsagesIDs() (ids []string) {
	for id := range m.removedusages {
		ids = append(ids, id)
	}
	return
}

// UsagesIDs returns the "usages" edge IDs in the mutation.
func (m *PromoCodeMutation) UsagesIDs() (ids []string) {
	for id := range m.usages {
		ids = append(ids, id)
	}
	return
}

// ResetUsages resets all changes to the "usages" edge.
func (m *PromoCodeMutation) ResetUsages() {
	m.usages = nil
	m.clearedusages = false
	m.removedusages = nil
}

// Where appends a list predicates to the PromoCodeMutation builder.
func (m *PromoCodeMutation) Where(ps ...predicate.PromoCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromoCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromoCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromoCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromoCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromoCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromoCode).
func (m *PromoCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromoCodeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.code != nil {
		fields = append(fields, promocode.FieldCode)
	}
	if m.discount_type != nil {
		fields = append(fields, promocode.FieldDiscountType)
	}
	if m.discount_value != nil {
		fields = append(fields, promocode.FieldDiscountValue)
	}
	if m.applies_to != nil {
		fields = append(fields, promocode.FieldAppliesTo)
	}
	if m.valid_from != nil {
		fields = append(fields, promocode.FieldValidFrom)
	}
	if m.valid_until != nil {
		fields = append(fields, promocode.FieldValidUntil)
	}
	if m.max_uses != nil {
		fields = append(fields, promocode.FieldMaxUses)
	}
	if m.uses_count != nil {
		fields = append(fields, promocode.FieldUsesCount)
	}
	if m.enabled != nil {
		fields = append(fields, promocode.FieldEnabled)
	}
	if m.created_at != nil {
		fields = append(fields, promocode.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromoCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promocode.FieldCode:
		return m.Code()
	case promocode.FieldDiscountType:
		return m.DiscountType()
	case promocode.FieldDiscountValue:
		return m.DiscountValue()
	case promocode.FieldAppliesTo:
		return m.AppliesTo()
	case promocode.FieldValidFrom:
		return m.ValidFrom()
	case promocode.FieldValidUntil:
		return m.ValidUntil()
	case promocode.FieldMaxUses:
		return m.MaxUses()
	case promocode.FieldUsesCount:
		return m.UsesCount()
	case promocode.FieldEnabled:
		return m.Enabled()
	case promocode.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromoCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promocode.FieldCode:
		return m.OldCode(ctx)
	case promocode.FieldDiscountType:
		return m.OldDiscountType(ctx)
	case promocode.FieldDiscountValue:
		return m.OldDiscountValue(ctx)
	case promocode.FieldAppliesTo:
		return m.OldAppliesTo(ctx)
	case promocode.FieldValidFrom:
		return m.OldValidFrom(ctx)
	case promocode.FieldValidUntil:
		return m.OldValidUntil(ctx)
	case promocode.FieldMaxUses:
		return m.OldMaxUses(ctx)
	case promocode.FieldUsesCount:
		return m.OldUsesCount(ctx)
	case promocode.FieldEnabled:
		return m.OldEnabled(ctx)
	case promocode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PromoCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromoCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promocode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case promocode.FieldDiscountType:
		v, ok := value.(promocode.DiscountType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountType(v)
		return nil
	case promocode.FieldDiscountValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountValue(v)
		return nil
	case promocode.FieldAppliesTo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppliesTo(v)
		return nil
	case promocode.FieldValidFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidFrom(v)
		return nil
	case promocode.FieldValidUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidUntil(v)
		return nil
	case promocode.FieldMaxUses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxUses(v)
		return nil
	case promocode.FieldUsesCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsesCount(v)
		return nil
	case promocode.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case promocode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PromoCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromoCodeMutation) AddedFields() []string {
	var fields []string
	if m.adddiscount_value != nil {
		fields = append(fields, promocode.FieldDiscountValue)
	}
	if m.addmax_uses != nil {
		fields = append(fields, promocode.FieldMaxUses)
	}
	if m.adduses_count != nil {
		fields = append(fields, promocode.FieldUsesCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromoCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promocode.FieldDiscountValue:
		return m.AddedDiscountValue()
	case promocode.FieldMaxUses:
		return m.AddedMaxUses()
	case promocode.FieldUsesCount:
		return m.AddedUsesCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromoCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promocode.FieldDiscountValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscountValue(v)
		return nil
	case promocode.FieldMaxUses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxUses(v)
		return nil
	case promocode.FieldUsesCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsesCount(v)
		return nil
	}
	return fmt.Errorf("unknown PromoCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromoCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promocode.FieldAppliesTo) {
		fields = append(fields, promocode.FieldAppliesTo)
	}
	if m.FieldCleared(promocode.FieldValidUntil) {
		fields = append(fields, promocode.FieldValidUntil)
	}
	if m.FieldCleared(promocode.FieldMaxUses) {
		fields = append(fields, promocode.FieldMaxUses)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromoCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromoCodeMutation) ClearField(name string) error {
	switch name {
	case promocode.FieldAppliesTo:
		m.ClearAppliesTo()
		return nil
	case promocode.FieldValidUntil:
		m.ClearValidUntil()
		return nil
	case promocode.FieldMaxUses:
		m.ClearMaxUses()
		return nil
	}
	return fmt.Errorf("unknown PromoCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromoCodeMutation) ResetField(name string) error {
	switch name {
	case promocode.FieldCode:
		m.ResetCode()
		return nil
	case promocode.FieldDiscountType:
		m.ResetDiscountType()
		return nil
	case promocode.FieldDiscountValue:
		m.ResetDiscountValue()
		return nil
	case promocode.FieldAppliesTo:
		m.ResetAppliesTo()
		return nil
	case promocode.FieldValidFrom:
		m.ResetValidFrom()
		return nil
	case promocode.FieldValidUntil:
		m.ResetValidUntil()
		return nil
	case promocode.FieldMaxUses:
		m.ResetMaxUses()
		return nil
	case promocode.FieldUsesCount:
		m.ResetUsesCount()
		return nil
	case promocode.FieldEnabled:
		m.ResetEnabled()
		return nil
	case promocode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PromoCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromoCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.usages != nil {
		edges = append(edges, promocode.EdgeUsages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromoCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promocode.EdgeUsages:
		ids := make([]ent.Value, 0, len(m.usages))
		for id := range m.usages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromoCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusages != nil {
		edges = append(edges, promocode.EdgeUsages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromoCodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case promocode.EdgeUsages:
		ids := make([]ent.Value, 0, len(m.removedusages))
		for id := range m.removedusages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromoCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusages {
		edges = append(edges, promocode.EdgeUsages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromoCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case promocode.EdgeUsages:
		return m.clearedusages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromoCodeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PromoCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromoCodeMutation) ResetEdge(name string) error {
	switch name {
	case promocode.EdgeUsages:
		m.ResetUsages()
		return nil
	}
	return fmt.Errorf("unknown PromoCode edge %s", name)
}

// PromoCodeUsageMutation represents an operation that mutates the PromoCodeUsage nodes in the graph.
type PromoCodeUsageMutation struct {
	config
	op                Op
	typ               string
	id                *string
	applied_at        *time.Time
	clearedFields     map[string]struct{}
	promo_code        *string
	clearedpromo_code bool
	team              *string
	clearedteam       bool
	done              bool
	oldValue          func(context.Context) (*PromoCodeUsage, error)
	predicates        []predicate.PromoCodeUsage
}

var _ ent.Mutation = (*PromoCodeUsageMutation)(nil)

// promocodeusageOption allows management of the mutation configuration using functional options.
type promocodeusageOption func(*PromoCodeUsageMutation)

// newPromoCodeUsageMutation creates new mutation for the PromoCodeUsage entity.
func newPromoCodeUsageMutation(c config, op Op, opts ...promocodeusageOption) *PromoCodeUsageMutation {
	m := &PromoCodeUsageMutation{
		config:        c,
		op:            op,
		typ:           TypePromoCodeUsage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromoCodeUsageID sets the ID field of the mutation.
func withPromoCodeUsageID(id string) promocodeusageOption {
	return func(m *PromoCodeUsageMutation) {
		var (
			err   error
			once  sync.Once
			value *PromoCodeUsage
		)
		m.oldValue = func(ctx context.Context) (*PromoCodeUsage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromoCodeUsage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromoCodeUsage sets the old PromoCodeUsage of the mutation.
func withPromoCodeUsage(node *PromoCodeUsage) promocodeusageOption {
	return func(m *PromoCodeUsageMutation) {
		m.oldValue = func(context.Context) (*PromoCodeUsage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromoCodeUsageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromoCodeUsageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PromoCodeUsage entities.
func (m *PromoCodeUsageMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromoCodeUsageMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromoCodeUsageMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromoCodeUsage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppliedAt sets the "applied_at" field.
func (m *PromoCodeUsageMutation) SetAppliedAt(t time.Time) {
	m.applied_at = &t
}

// AppliedAt returns the value of the "applied_at" field in the mutation.
func (m *PromoCodeUsageMutation) AppliedAt() (r time.Time, exists bool) {
	v := m.applied_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAppliedAt returns the old "applied_at" field's value of the PromoCodeUsage entity.
// If the PromoCodeUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeUsageMutation) OldAppliedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppliedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppliedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppliedAt: %w", err)
	}
	return oldValue.AppliedAt, nil
}

// ResetAppliedAt resets all changes to the "applied_at" field.
func (m *PromoCodeUsageMutation) ResetAppliedAt() {
	m.applied_at = nil
}

// SetPromoCodeID sets the "promo_code" edge to the PromoCode entity by id.
func (m *PromoCodeUsageMutation) SetPromoCodeID(id string) {
	m.promo_code = &id
}

// ClearPromoCode clears the "promo_code" edge to the PromoCode entity.
func (m *PromoCodeUsageMutation) ClearPromoCode() {
	m.clearedpromo_code = true
}

// PromoCodeCleared reports if the "promo_code" edge to the PromoCode entity was cleared.
func (m *PromoCodeUsageMutation) PromoCodeCleared() bool {
	return m.clearedpromo_code
}

// PromoCodeID returns the "promo_code" edge ID in the mutation.
func (m *PromoCodeUsageMutation) PromoCodeID() (id string, exists bool) {
	if m.promo_code != nil {
		return *m.promo_code, true
	}
	return
}

// PromoCodeIDs returns the "promo_code" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PromoCodeID instead. It exists only for internal usage by the builders.
func (m *PromoCodeUsageMutation) PromoCodeIDs() (ids []string) {
	if id := m.promo_code; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPromoCode resets all changes to the "promo_code" edge.
func (m *PromoCodeUsageMutation) ResetPromoCode() {
	m.promo_code = nil
	m.clearedpromo_code = false
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *PromoCodeUsageMutation) SetTeamID(id string) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *PromoCodeUsageMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *PromoCodeUsageMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *PromoCodeUsageMutation) TeamID() (id string, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *PromoCodeUsageMutation) TeamIDs() (ids []string) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *PromoCodeUsageMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the PromoCodeUsageMutation builder.
func (m *PromoCodeUsageMutation) Where(ps ...predicate.PromoCodeUsage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromoCodeUsageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromoCodeUsageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromoCodeUsage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromoCodeUsageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromoCodeUsageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromoCodeUsage).
func (m *PromoCodeUsageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromoCodeUsageMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.applied_at != nil {
		fields = append(fields, promocodeusage.FieldAppliedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromoCodeUsageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promocodeusage.FieldAppliedAt:
		return m.AppliedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromoCodeUsageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promocodeusage.FieldAppliedAt:
		return m.OldAppliedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PromoCodeUsage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromoCodeUsageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promocodeusage.FieldAppliedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppliedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PromoCodeUsage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromoCodeUsageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromoCodeUsageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromoCodeUsageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PromoCodeUsage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromoCodeUsageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromoCodeUsageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromoCodeUsageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PromoCodeUsage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromoCodeUsageMutation) ResetField(name string) error {
	switch name {
	case promocodeusage.FieldAppliedAt:
		m.ResetAppliedAt()
		return nil
	}
	return fmt.Errorf("unknown PromoCodeUsage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromoCodeUsageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.promo_code != nil {
		edges = append(edges, promocodeusage.EdgePromoCode)
	}
	if m.team != nil {
		edges = append(edges, promocodeusage.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromoCodeUsageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promocodeusage.EdgePromoCode:
		if id := m.promo_code; id != nil {
			return []ent.Value{*id}
		}
	case promocodeusage.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromoCodeUsageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromoCodeUsageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromoCodeUsageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpromo_code {
		edges = append(edges, promocodeusage.EdgePromoCode)
	}
	if m.clearedteam {
		edges = append(edges, promocodeusage.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromoCodeUsageMutation) EdgeCleared(name string) bool {
	switch name {
	case promocodeusage.EdgePromoCode:
		return m.clearedpromo_code
	case promocodeusage.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromoCodeUsageMutation) ClearEdge(name string) error {
	switch name {
	case promocodeusage.EdgePromoCode:
		m.ClearPromoCode()
		return nil
	case promocodeusage.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown PromoCodeUsage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromoCodeUsageMutation) ResetEdge(name string) error {
	switch name {
	case promocodeusage.EdgePromoCode:
		m.ResetPromoCode()
		return nil
	case promocodeusage.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown PromoCodeUsage edge %s", name)
}

// ScrapeJobMutation represents an operation that mutates the ScrapeJob nodes in the graph.
type ScrapeJobMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	status              *scrapejob.Status
	slots_found         *int
	addslots_found      *int
	error_message       *string
	scrape_status       *string
	diagnostics         *string
	started_at          *time.Time
	completed_at        *time.Time
	created_at          *time.Time
	clearedFields       map[string]struct{}
	municipality        *string
	clearedmunicipality bool
	done                bool
	oldValue            func(context.Context) (*ScrapeJob, error)
	predicates          []predicate.ScrapeJob
}

var _ ent.Mutation = (*ScrapeJobMutation)(nil)

// scrapejobOption allows management of the mutation configuration using functional options.
type scrapejobOption func(*ScrapeJobMutation)

// newScrapeJobMutation creates new mutation for the ScrapeJob entity.
func newScrapeJobMutation(c config, op Op, opts ...scrapejobOption) *ScrapeJobMutation {
	m := &ScrapeJobMutation{
		config:        c,
		op:            op,
		typ:           TypeScrapeJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScrapeJobID sets the ID field of the mutation.
func withScrapeJobID(id string) scrapejobOption {
	return func(m *ScrapeJobMutation) {
		var (
			err   error
			once  sync.Once
			value *ScrapeJob
		)
		m.oldValue = func(ctx context.Context) (*ScrapeJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScrapeJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScrapeJob sets the old ScrapeJob of the mutation.
func withScrapeJob(node *ScrapeJob) scrapejobOption {
	return func(m *ScrapeJobMutation) {
		m.oldValue = func(context.Context) (*ScrapeJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScrapeJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScrapeJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScrapeJob entities.
func (m *ScrapeJobMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScrapeJobMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScrapeJobMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScrapeJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *ScrapeJobMutation) SetStatus(s scrapejob.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ScrapeJobMutation) Status() (r scrapejob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ScrapeJob entity.
// If the ScrapeJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScrapeJobMutation) OldStatus(ctx context.Context) (v scrapejob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ScrapeJobMutation) ResetStatus() {
	m.status = nil
}

// SetSlotsFound sets the "slots_found" field.
func (m *ScrapeJobMutation) SetSlotsFound(i int) {
	m.slots_found = &i
	m.addslots_found = nil
}

// SlotsFound returns the value of the "slots_found" field in the mutation.
func (m *ScrapeJobMutation) SlotsFound() (r int, exists bool) {
	v := m.slots_found
	if v == nil {
		return
	}
	return *v, true
}

// OldSlotsFound returns the old "slots_found" field's value of the ScrapeJob entity.
// If the ScrapeJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScrapeJobMutation) OldSlotsFound(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlotsFound is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlotsFound requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlotsFound: %w", err)
	}
	return oldValue.SlotsFound, nil
}

// AddSlotsFound adds i to the "slots_found" field.
func (m *ScrapeJobMutation) AddSlotsFound(i int) {
	if m.addslots_found != nil {
		*m.addslots_found += i
	} else {
		m.addslots_found = &i
	}
}

// AddedSlotsFound returns the value that was added to the "slots_found" field in this mutation.
func (m *ScrapeJobMutation) AddedSlotsFound() (r int, exists bool) {
	v := m.addslots_found
	if v == nil {
		return
	}
	return *v, true
}

// ResetSlotsFound resets all changes to the "slots_found" field.
func (m *ScrapeJobMutation) ResetSlotsFound() {
	m.slots_found = nil
	m.addslots_found = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *ScrapeJobMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ScrapeJobMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the ScrapeJob entity.
// If the ScrapeJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScrapeJobMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ScrapeJobMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[scrapejob.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ScrapeJobMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[scrapejob.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ScrapeJobMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, scrapejob.FieldErrorMessage)
}

// SetScrapeStatus sets the "scrape_status" field.
func (m *ScrapeJobMutation) SetScrapeStatus(s string) {
	m.scrape_status = &s
}

// ScrapeStatus returns the value of the "scrape_status" field in the mutation.
func (m *ScrapeJobMutation) ScrapeStatus() (r string, exists bool) {
	v := m.scrape_status
	if v == nil {
		return
	}
	return *v, true
}

// OldScrapeStatus returns the old "scrape_status" field's value of the ScrapeJob entity.
// If the ScrapeJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScrapeJobMutation) OldScrapeStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScrapeStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScrapeStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScrapeStatus: %w", err)
	}
	return oldValue.ScrapeStatus, nil
}

// ClearScrapeStatus clears the value of the "scrape_status" field.
func (m *ScrapeJobMutation) ClearScrapeStatus() {
	m.scrape_status = nil
	m.clearedFields[scrapejob.FieldScrapeStatus] = struct{}{}
}

// ScrapeStatusCleared returns if the "scrape_status" field was cleared in this mutation.
func (m *ScrapeJobMutation) ScrapeStatusCleared() bool {
	_, ok := m.clearedFields[scrapejob.FieldScrapeStatus]
	return ok
}

// ResetScrapeStatus resets all changes to the "scrape_status" field.
func (m *ScrapeJobMutation) ResetScrapeStatus() {
	m.scrape_status = nil
	delete(m.clearedFields, scrapejob.FieldScrapeStatus)
}

// SetDiagnostics sets the "diagnostics" field.
func (m *ScrapeJobMutation) SetDiagnostics(s string) {
	m.diagnostics = &s
}

// Diagnostics returns the value of the "diagnostics" field in the mutation.
func (m *ScrapeJobMutation) Diagnostics() (r string, exists bool) {
	v := m.diagnostics
	if v == nil {
		return
	}
	return *v, true
}

// OldDiagnostics returns the old "diagnostics" field's value of the ScrapeJob entity.
// If the ScrapeJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScrapeJobMutation) OldDiagnostics(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiagnostics is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiagnostics requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiagnostics: %w", err)
	}
	return oldValue.Diagnostics, nil
}

// ClearDiagnostics clears the value of the "diagnostics" field.
func (m *ScrapeJobMutation) ClearDiagnostics() {
	m.diagnostics = nil
	m.clearedFields[scrapejob.FieldDiagnostics] = struct{}{}
}

// DiagnosticsCleared returns if the "diagnostics" field was cleared in this mutation.
func (m *ScrapeJobMutation) DiagnosticsCleared() bool {
	_, ok := m.clearedFields[scrapejob.FieldDiagnostics]
	return ok
}

// ResetDiagnostics resets all changes to the "diagnostics" field.
func (m *ScrapeJobMutation) ResetDiagnostics() {
	m.diagnostics = nil
	delete(m.clearedFields, scrapejob.FieldDiagnostics)
}

// SetStartedAt sets the "started_at" field.
func (m *ScrapeJobMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ScrapeJobMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the ScrapeJob entity.
// If the ScrapeJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScrapeJobMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *ScrapeJobMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[scrapejob.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *ScrapeJobMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[scrapejob.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ScrapeJobMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, scrapejob.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *ScrapeJobMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *ScrapeJobMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the ScrapeJob entity.
// If the ScrapeJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScrapeJobMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *ScrapeJobMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[scrapejob.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *ScrapeJobMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[scrapejob.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *ScrapeJobMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, scrapejob.FieldCompletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ScrapeJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScrapeJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ScrapeJob entity.
// If the ScrapeJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScrapeJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScrapeJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetMunicipalityID sets the "municipality" edge to the Municipality entity by id.
func (m *ScrapeJobMutation) SetMunicipalityID(id string) {
	m.municipality = &id
}

// ClearMunicipality clears the "municipality" edge to the Municipality entity.
func (m *ScrapeJobMutation) ClearMunicipality() {
	m.clearedmunicipality = true
}

// MunicipalityCleared reports if the "municipality" edge to the Municipality entity was cleared.
func (m *ScrapeJobMutation) MunicipalityCleared() bool {
	return m.clearedmunicipality
}

// MunicipalityID returns the "municipality" edge ID in the mutation.
func (m *ScrapeJobMutation) MunicipalityID() (id string, exists bool) {
	if m.municipality != nil {
		return *m.municipality, true
	}
	return
}

// MunicipalityIDs returns the "municipality" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MunicipalityID instead. It exists only for internal usage by the builders.
func (m *ScrapeJobMutation) MunicipalityIDs() (ids []string) {
	if id := m.municipality; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMunicipality resets all changes to the "municipality" edge.
func (m *ScrapeJobMutation) ResetMunicipality() {
	m.municipality = nil
	m.clearedmunicipality = false
}

// Where appends a list predicates to the ScrapeJobMutation builder.
func (m *ScrapeJobMutation) Where(ps ...predicate.ScrapeJob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScrapeJobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScrapeJobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScrapeJob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScrapeJobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScrapeJobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScrapeJob).
func (m *ScrapeJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScrapeJobMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.status != nil {
		fields = append(fields, scrapejob.FieldStatus)
	}
	if m.slots_found != nil {
		fields = append(fields, scrapejob.FieldSlotsFound)
	}
	if m.error_message != nil {
		fields = append(fields, scrapejob.FieldErrorMessage)
	}
	if m.scrape_status != nil {
		fields = append(fields, scrapejob.FieldScrapeStatus)
	}
	if m.diagnostics != nil {
		fields = append(fields, scrapejob.FieldDiagnostics)
	}
	if m.started_at != nil {
		fields = append(fields, scrapejob.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, scrapejob.FieldCompletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, scrapejob.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScrapeJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scrapejob.FieldStatus:
		return m.Status()
	case scrapejob.FieldSlotsFound:
		return m.SlotsFound()
	case scrapejob.FieldErrorMessage:
		return m.ErrorMessage()
	case scrapejob.FieldScrapeStatus:
		return m.ScrapeStatus()
	case scrapejob.FieldDiagnostics:
		return m.Diagnostics()
	case scrapejob.FieldStartedAt:
		return m.StartedAt()
	case scrapejob.FieldCompletedAt:
		return m.CompletedAt()
	case scrapejob.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScrapeJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scrapejob.FieldStatus:
		return m.OldStatus(ctx)
	case scrapejob.FieldSlotsFound:
		return m.OldSlotsFound(ctx)
	case scrapejob.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case scrapejob.FieldScrapeStatus:
		return m.OldScrapeStatus(ctx)
	case scrapejob.FieldDiagnostics:
		return m.OldDiagnostics(ctx)
	case scrapejob.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case scrapejob.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case scrapejob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ScrapeJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScrapeJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scrapejob.FieldStatus:
		v, ok := value.(scrapejob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case scrapejob.FieldSlotsFound:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlotsFound(v)
		return nil
	case scrapejob.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case scrapejob.FieldScrapeStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScrapeStatus(v)
		return nil
	case scrapejob.FieldDiagnostics:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiagnostics(v)
		return nil
	case scrapejob.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case scrapejob.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case scrapejob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ScrapeJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScrapeJobMutation) AddedFields() []string {
	var fields []string
	if m.addslots_found != nil {
		fields = append(fields, scrapejob.FieldSlotsFound)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScrapeJobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case scrapejob.FieldSlotsFound:
		return m.AddedSlotsFound()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScrapeJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case scrapejob.FieldSlotsFound:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSlotsFound(v)
		return nil
	}
	return fmt.Errorf("unknown ScrapeJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScrapeJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(scrapejob.FieldErrorMessage) {
		fields = append(fields, scrapejob.FieldErrorMessage)
	}
	if m.FieldCleared(scrapejob.FieldScrapeStatus) {
		fields = append(fields, scrapejob.FieldScrapeStatus)
	}
	if m.FieldCleared(scrapejob.FieldDiagnostics) {
		fields = append(fields, scrapejob.FieldDiagnostics)
	}
	if m.FieldCleared(scrapejob.FieldStartedAt) {
		fields = append(fields, scrapejob.FieldStartedAt)
	}
	if m.FieldCleared(scrapejob.FieldCompletedAt) {
		fields = append(fields, scrapejob.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScrapeJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScrapeJobMutation) ClearField(name string) error {
	switch name {
	case scrapejob.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case scrapejob.FieldScrapeStatus:
		m.ClearScrapeStatus()
		return nil
	case scrapejob.FieldDiagnostics:
		m.ClearDiagnostics()
		return nil
	case scrapejob.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case scrapejob.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown ScrapeJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScrapeJobMutation) ResetField(name string) error {
	switch name {
	case scrapejob.FieldStatus:
		m.ResetStatus()
		return nil
	case scrapejob.FieldSlotsFound:
		m.ResetSlotsFound()
		return nil
	case scrapejob.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case scrapejob.FieldScrapeStatus:
		m.ResetScrapeStatus()
		return nil
	case scrapejob.FieldDiagnostics:
		m.ResetDiagnostics()
		return nil
	case scrapejob.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case scrapejob.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case scrapejob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ScrapeJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScrapeJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.municipality != nil {
		edges = append(edges, scrapejob.EdgeMunicipality)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScrapeJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scrapejob.EdgeMunicipality:
		if id := m.municipality; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScrapeJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScrapeJobMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScrapeJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmunicipality {
		edges = append(edges, scrapejob.EdgeMunicipality)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScrapeJobMutation) EdgeCleared(name string) bool {
	switch name {
	case scrapejob.EdgeMunicipality:
		return m.clearedmunicipality
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScrapeJobMutation) ClearEdge(name string) error {
	switch name {
	case scrapejob.EdgeMunicipality:
		m.ClearMunicipality()
		return nil
	}
	return fmt.Errorf("unknown ScrapeJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScrapeJobMutation) ResetEdge(name string) error {
	switch name {
	case scrapejob.EdgeMunicipality:
		m.ResetMunicipality()
		return nil
	}
	return fmt.Errorf("unknown ScrapeJob edge %s", name)
}

// SlotMutation represents an operation that mutates the Slot nodes in the graph.
type SlotMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	slot_date            *time.Time
	time_from            *string
	time_to              *string
	court_name           *string
	raw_text             *string
	scraped_at           *time.Time
	clearedFields        map[string]struct{}
	facility             *string
	clearedfacility      bool
	municipality         *string
	clearedmunicipality  bool
	ground               *string
	clearedground        bool
	notifications        map[string]struct{}
	removednotifications map[string]struct{}
	clearednotifications bool
	done                 bool
	oldValue             func(context.Context) (*Slot, error)
	predicates           []predicate.Slot
}

var _ ent.Mutation = (*SlotMutation)(nil)

// slotOption allows management of the mutation configuration using functional options.
type slotOption func(*SlotMutation)

// newSlotMutation creates new mutation for the Slot entity.
func newSlotMutation(c config, op Op, opts ...slotOption) *SlotMutation {
	m := &SlotMutation{
		config:        c,
		op:            op,
		typ:           TypeSlot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSlotID sets the ID field of the mutation.
func withSlotID(id string) slotOption {
	return func(m *SlotMutation) {
		var (
			err   error
			once  sync.Once
			value *Slot
		)
		m.oldValue = func(ctx context.Context) (*Slot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Slot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSlot sets the old Slot of the mutation.
func withSlot(node *Slot) slotOption {
	return func(m *SlotMutation) {
		m.oldValue = func(context.Context) (*Slot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SlotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SlotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Slot entities.
func (m *SlotMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SlotMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SlotMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Slot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlotDate sets the "slot_date" field.
func (m *SlotMutation) SetSlotDate(t time.Time) {
	m.slot_date = &t
}

// SlotDate returns the value of the "slot_date" field in the mutation.
func (m *SlotMutation) SlotDate() (r time.Time, exists bool) {
	v := m.slot_date
	if v == nil {
		return
	}
	return *v, true
}

// OldSlotDate returns the old "slot_date" field's value of the Slot entity.
// If the Slot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SlotMutation) OldSlotDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlotDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlotDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlotDate: %w", err)
	}
	return oldValue.SlotDate, nil
}

// ResetSlotDate resets all changes to the "slot_date" field.
func (m *SlotMutation) ResetSlotDate() {
	m.slot_date = nil
}

// SetTimeFrom sets the "time_from" field.
func (m *SlotMutation) SetTimeFrom(s string) {
	m.time_from = &s
}

// TimeFrom returns the value of the "time_from" field in the mutation.
func (m *SlotMutation) TimeFrom() (r string, exists bool) {
	v := m.time_from
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeFrom returns the old "time_from" field's value of the Slot entity.
// If the Slot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SlotMutation) OldTimeFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeFrom: %w", err)
	}
	return oldValue.TimeFrom, nil
}

// ResetTimeFrom resets all changes to the "time_from" field.
func (m *SlotMutation) ResetTimeFrom() {
	m.time_from = nil
}

// SetTimeTo sets the "time_to" field.
func (m *SlotMutation) SetTimeTo(s string) {
	m.time_to = &s
}

// TimeTo returns the value of the "time_to" field in the mutation.
func (m *SlotMutation) TimeTo() (r string, exists bool) {
	v := m.time_to
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeTo returns the old "time_to" field's value of the Slot entity.
// If the Slot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SlotMutation) OldTimeTo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeTo: %w", err)
	}
	return oldValue.TimeTo, nil
}

// ResetTimeTo resets all changes to the "time_to" field.
func (m *SlotMutation) ResetTimeTo() {
	m.time_to = nil
}

// SetCourtName sets the "court_name" field.
func (m *SlotMutation) SetCourtName(s string) {
	m.court_name = &s
}

// CourtName returns the value of the "court_name" field in the mutation.
func (m *SlotMutation) CourtName() (r string, exists bool) {
	v := m.court_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCourtName returns the old "court_name" field's value of the Slot entity.
// If the Slot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SlotMutation) OldCourtName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourtName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourtName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourtName: %w", err)
	}
	return oldValue.CourtName, nil
}

// ClearCourtName clears the value of the "court_name" field.
func (m *SlotMutation) ClearCourtName() {
	m.court_name = nil
	m.clearedFields[slot.FieldCourtName] = struct{}{}
}

// CourtNameCleared returns if the "court_name" field was cleared in this mutation.
func (m *SlotMutation) CourtNameCleared() bool {
	_, ok := m.clearedFields[slot.FieldCourtName]
	return ok
}

// ResetCourtName resets all changes to the "court_name" field.
func (m *SlotMutation) ResetCourtName() {
	m.court_name = nil
	delete(m.clearedFields, slot.FieldCourtName)
}

// SetRawText sets the "raw_text" field.
func (m *SlotMutation) SetRawText(s string) {
	m.raw_text = &s
}

// RawText returns the value of the "raw_text" field in the mutation.
func (m *SlotMutation) RawText() (r string, exists bool) {
	v := m.raw_text
	if v == nil {
		return
	}
	return *v, true
}

// OldRawText returns the old "raw_text" field's value of the Slot entity.
// If the Slot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SlotMutation) OldRawText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawText: %w", err)
	}
	return oldValue.RawText, nil
}

// ClearRawText clears the value of the "raw_text" field.
func (m *SlotMutation) ClearRawText() {
	m.raw_text = nil
	m.clearedFields[slot.FieldRawText] = struct{}{}
}

// RawTextCleared returns if the "raw_text" field was cleared in this mutation.
func (m *SlotMutation) RawTextCleared() bool {
	_, ok := m.clearedFields[slot.FieldRawText]
	return ok
}

// ResetRawText resets all changes to the "raw_text" field.
func (m *SlotMutation) ResetRawText() {
	m.raw_text = nil
	delete(m.clearedFields, slot.FieldRawText)
}

// SetScrapedAt sets the "scraped_at" field.
func (m *SlotMutation) SetScrapedAt(t time.Time) {
	m.scraped_at = &t
}

// ScrapedAt returns the value of the "scraped_at" field in the mutation.
func (m *SlotMutation) ScrapedAt() (r time.Time, exists bool) {
	v := m.scraped_at
	if v == nil {
		return
	}
	return *v, true
}

// OldScrapedAt returns the old "scraped_at" field's value of the Slot entity.
// If the Slot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SlotMutation) OldScrapedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScrapedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScrapedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScrapedAt: %w", err)
	}
	return oldValue.ScrapedAt, nil
}

// ResetScrapedAt resets all changes to the "scraped_at" field.
func (m *SlotMutation) ResetScrapedAt() {
	m.scraped_at = nil
}

// SetFacilityID sets the "facility" edge to the Facility entity by id.
func (m *SlotMutation) SetFacilityID(id string) {
	m.facility = &id
}

// ClearFacility clears the "facility" edge to the Facility entity.
func (m *SlotMutation) ClearFacility() {
	m.clearedfacility = true
}

// FacilityCleared reports if the "facility" edge to the Facility entity was cleared.
func (m *SlotMutation) FacilityCleared() bool {
	return m.clearedfacility
}

// FacilityID returns the "facility" edge ID in the mutation.
func (m *SlotMutation) FacilityID() (id string, exists bool) {
	if m.facility != nil {
		return *m.facility, true
	}
	return
}

// FacilityIDs returns the "facility" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FacilityID instead. It exists only for internal usage by the builders.
func (m *SlotMutation) FacilityIDs() (ids []string) {
	if id := m.facility; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFacility resets all changes to the "facility" edge.
func (m *SlotMutation) ResetFacility() {
	m.facility = nil
	m.clearedfacility = false
}

// SetMunicipalityID sets the "municipality" edge to the Municipality entity by id.
func (m *SlotMutation) SetMunicipalityID(id string) {
	m.municipality = &id
}

// ClearMunicipality clears the "municipality" edge to the Municipality entity.
func (m *SlotMutation) ClearMunicipality() {
	m.clearedmunicipality = true
}

// MunicipalityCleared reports if the "municipality" edge to the Municipality entity was cleared.
func (m *SlotMutation) MunicipalityCleared() bool {
	return m.clearedmunicipality
}

// MunicipalityID returns the "municipality" edge ID in the mutation.
func (m *SlotMutation) MunicipalityID() (id string, exists bool) {
	if m.municipality != nil {
		return *m.municipality, true
	}
	return
}

// MunicipalityIDs returns the "municipality" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MunicipalityID instead. It exists only for internal usage by the builders.
func (m *SlotMutation) MunicipalityIDs() (ids []string) {
	if id := m.municipality; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMunicipality resets all changes to the "municipality" edge.
func (m *SlotMutation) ResetMunicipality() {
	m.municipality = nil
	m.clearedmunicipality = false
}

// SetGroundID sets the "ground" edge to the Ground entity by id.
func (m *SlotMutation) SetGroundID(id string) {
	m.ground = &id
}

// ClearGround clears the "ground" edge to the Ground entity.
func (m *SlotMutation) ClearGround() {
	m.clearedground = true
}

// GroundCleared reports if the "ground" edge to the Ground entity was cleared.
func (m *SlotMutation) GroundCleared() bool {
	return m.clearedground
}

// GroundID returns the "ground" edge ID in the mutation.
func (m *SlotMutation) GroundID() (id string, exists bool) {
	if m.ground != nil {
		return *m.ground, true
	}
	return
}

// GroundIDs returns the "ground" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroundID instead. It exists only for internal usage by the builders.
func (m *SlotMutation) GroundIDs() (ids []string) {
	if id := m.ground; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGround resets all changes to the "ground" edge.
func (m *SlotMutation) ResetGround() {
	m.ground = nil
	m.clearedground = false
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *SlotMutation) AddNotificationIDs(ids ...string) {
	if m.notifications == nil {
		m.notifications = make(map[string]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *SlotMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *SlotMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *SlotMutation) RemoveNotificationIDs(ids ...string) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *SlotMutation) RemovedNotificationsIDs() (ids []string) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *SlotMutation) NotificationsIDs() (ids []string) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *SlotMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// Where appends a list predicates to the SlotMutation builder.
func (m *SlotMutation) Where(ps ...predicate.Slot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SlotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SlotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Slot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SlotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SlotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Slot).
func (m *SlotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SlotMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.slot_date != nil {
		fields = append(fields, slot.FieldSlotDate)
	}
	if m.time_from != nil {
		fields = append(fields, slot.FieldTimeFrom)
	}
	if m.time_to != nil {
		fields = append(fields, slot.FieldTimeTo)
	}
	if m.court_name != nil {
		fields = append(fields, slot.FieldCourtName)
	}
	if m.raw_text != nil {
		fields = append(fields, slot.FieldRawText)
	}
	if m.scraped_at != nil {
		fields = append(fields, slot.FieldScrapedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SlotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case slot.FieldSlotDate:
		return m.SlotDate()
	case slot.FieldTimeFrom:
		return m.TimeFrom()
	case slot.FieldTimeTo:
		return m.TimeTo()
	case slot.FieldCourtName:
		return m.CourtName()
	case slot.FieldRawText:
		return m.RawText()
	case slot.FieldScrapedAt:
		return m.ScrapedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SlotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case slot.FieldSlotDate:
		return m.OldSlotDate(ctx)
	case slot.FieldTimeFrom:
		return m.OldTimeFrom(ctx)
	case slot.FieldTimeTo:
		return m.OldTimeTo(ctx)
	case slot.FieldCourtName:
		return m.OldCourtName(ctx)
	case slot.FieldRawText:
		return m.OldRawText(ctx)
	case slot.FieldScrapedAt:
		return m.OldScrapedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Slot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SlotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case slot.FieldSlotDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlotDate(v)
		return nil
	case slot.FieldTimeFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeFrom(v)
		return nil
	case slot.FieldTimeTo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeTo(v)
		return nil
	case slot.FieldCourtName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourtName(v)
		return nil
	case slot.FieldRawText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawText(v)
		return nil
	case slot.FieldScrapedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScrapedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Slot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SlotMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SlotMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SlotMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Slot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SlotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(slot.FieldCourtName) {
		fields = append(fields, slot.FieldCourtName)
	}
	if m.FieldCleared(slot.FieldRawText) {
		fields = append(fields, slot.FieldRawText)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SlotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SlotMutation) ClearField(name string) error {
	switch name {
	case slot.FieldCourtName:
		m.ClearCourtName()
		return nil
	case slot.FieldRawText:
		m.ClearRawText()
		return nil
	}
	return fmt.Errorf("unknown Slot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SlotMutation) ResetField(name string) error {
	switch name {
	case slot.FieldSlotDate:
		m.ResetSlotDate()
		return nil
	case slot.FieldTimeFrom:
		m.ResetTimeFrom()
		return nil
	case slot.FieldTimeTo:
		m.ResetTimeTo()
		return nil
	case slot.FieldCourtName:
		m.ResetCourtName()
		return nil
	case slot.FieldRawText:
		m.ResetRawText()
		return nil
	case slot.FieldScrapedAt:
		m.ResetScrapedAt()
		return nil
	}
	return fmt.Errorf("unknown Slot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SlotMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.facility != nil {
		edges = append(edges, slot.EdgeFacility)
	}
	if m.municipality != nil {
		edges = append(edges, slot.EdgeMunicipality)
	}
	if m.ground != nil {
		edges = append(edges, slot.EdgeGround)
	}
	if m.notifications != nil {
		edges = append(edges, slot.EdgeNotifications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SlotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case slot.EdgeFacility:
		if id := m.facility; id != nil {
			return []ent.Value{*id}
		}
	case slot.EdgeMunicipality:
		if id := m.municipality; id != nil {
			return []ent.Value{*id}
		}
	case slot.EdgeGround:
		if id := m.ground; id != nil {
			return []ent.Value{*id}
		}
	case slot.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SlotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removednotifications != nil {
		edges = append(edges, slot.EdgeNotifications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SlotMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case slot.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SlotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedfacility {
		edges = append(edges, slot.EdgeFacility)
	}
	if m.clearedmunicipality {
		edges = append(edges, slot.EdgeMunicipality)
	}
	if m.clearedground {
		edges = append(edges, slot.EdgeGround)
	}
	if m.clearednotifications {
		edges = append(edges, slot.EdgeNotifications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SlotMutation) EdgeCleared(name string) bool {
	switch name {
	case slot.EdgeFacility:
		return m.clearedfacility
	case slot.EdgeMunicipality:
		return m.clearedmunicipality
	case slot.EdgeGround:
		return m.clearedground
	case slot.EdgeNotifications:
		return m.clearednotifications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SlotMutation) ClearEdge(name string) error {
	switch name {
	case slot.EdgeFacility:
		m.ClearFacility()
		return nil
	case slot.EdgeMunicipality:
		m.ClearMunicipality()
		return nil
	case slot.EdgeGround:
		m.ClearGround()
		return nil
	}
	return fmt.Errorf("unknown Slot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SlotMutation) ResetEdge(name string) error {
	switch name {
	case slot.EdgeFacility:
		m.ResetFacility()
		return nil
	case slot.EdgeMunicipality:
		m.ResetMunicipality()
		return nil
	case slot.EdgeGround:
		m.ResetGround()
		return nil
	case slot.EdgeNotifications:
		m.ResetNotifications()
		return nil
	}
	return fmt.Errorf("unknown Slot edge %s", name)
}

// SupportMessageMutation represents an operation that mutates the SupportMessage nodes in the graph.
type SupportMessageMutation struct {
	config
	op            Op
	typ           string
	id            *string
	role          *supportmessage.Role
	content       *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	ticket        *string
	clearedticket bool
	done          bool
	oldValue      func(context.Context) (*SupportMessage, error)
	predicates    []predicate.SupportMessage
}

var _ ent.Mutation = (*SupportMessageMutation)(nil)

// supportmessageOption allows management of the mutation configuration using functional options.
type supportmessageOption func(*SupportMessageMutation)

// newSupportMessageMutation creates new mutation for the SupportMessage entity.
func newSupportMessageMutation(c config, op Op, opts ...supportmessageOption) *SupportMessageMutation {
	m := &SupportMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeSupportMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSupportMessageID sets the ID field of the mutation.
func withSupportMessageID(id string) supportmessageOption {
	return func(m *SupportMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *SupportMessage
		)
		m.oldValue = func(ctx context.Context) (*SupportMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SupportMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSupportMessage sets the old SupportMessage of the mutation.
func withSupportMessage(node *SupportMessage) supportmessageOption {
	return func(m *SupportMessageMutation) {
		m.oldValue = func(context.Context) (*SupportMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SupportMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SupportMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SupportMessage entities.
func (m *SupportMessageMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SupportMessageMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SupportMessageMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SupportMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRole sets the "role" field.
func (m *SupportMessageMutation) SetRole(s supportmessage.Role) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *SupportMessageMutation) Role() (r supportmessage.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the SupportMessage entity.
// If the SupportMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupportMessageMutation) OldRole(ctx context.Context) (v supportmessage.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *SupportMessageMutation) ResetRole() {
	m.role = nil
}

// SetContent sets the "content" field.
func (m *SupportMessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *SupportMessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the SupportMessage entity.
// If the SupportMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupportMessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *SupportMessageMutation) ResetContent() {
	m.content = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SupportMessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SupportMessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SupportMessage entity.
// If the SupportMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupportMessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SupportMessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTicketID sets the "ticket" edge to the SupportTicket entity by id.
func (m *SupportMessageMutation) SetTicketID(id string) {
	m.ticket = &id
}

// ClearTicket clears the "ticket" edge to the SupportTicket entity.
func (m *SupportMessageMutation) ClearTicket() {
	m.clearedticket = true
}

// TicketCleared reports if the "ticket" edge to the SupportTicket entity was cleared.
func (m *SupportMessageMutation) TicketCleared() bool {
	return m.clearedticket
}

// TicketID returns the "ticket" edge ID in the mutation.
func (m *SupportMessageMutation) TicketID() (id string, exists bool) {
	if m.ticket != nil {
		return *m.ticket, true
	}
	return
}

// TicketIDs returns the "ticket" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TicketID instead. It exists only for internal usage by the builders.
func (m *SupportMessageMutation) TicketIDs() (ids []string) {
	if id := m.ticket; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTicket resets all changes to the "ticket" edge.
func (m *SupportMessageMutation) ResetTicket() {
	m.ticket = nil
	m.clearedticket = false
}

// Where appends a list predicates to the SupportMessageMutation builder.
func (m *SupportMessageMutation) Where(ps ...predicate.SupportMessage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SupportMessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SupportMessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SupportMessage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SupportMessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SupportMessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SupportMessage).
func (m *SupportMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SupportMessageMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.role != nil {
		fields = append(fields, supportmessage.FieldRole)
	}
	if m.content != nil {
		fields = append(fields, supportmessage.FieldContent)
	}
	if m.created_at != nil {
		fields = append(fields, supportmessage.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SupportMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case supportmessage.FieldRole:
		return m.Role()
	case supportmessage.FieldContent:
		return m.Content()
	case supportmessage.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SupportMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case supportmessage.FieldRole:
		return m.OldRole(ctx)
	case supportmessage.FieldContent:
		return m.OldContent(ctx)
	case supportmessage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SupportMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupportMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case supportmessage.FieldRole:
		v, ok := value.(supportmessage.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case supportmessage.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case supportmessage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SupportMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SupportMessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SupportMessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupportMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SupportMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SupportMessageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SupportMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SupportMessageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SupportMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SupportMessageMutation) ResetField(name string) error {
	switch name {
	case supportmessage.FieldRole:
		m.ResetRole()
		return nil
	case supportmessage.FieldContent:
		m.ResetContent()
		return nil
	case supportmessage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SupportMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SupportMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.ticket != nil {
		edges = append(edges, supportmessage.EdgeTicket)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SupportMessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case supportmessage.EdgeTicket:
		if id := m.ticket; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SupportMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SupportMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SupportMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedticket {
		edges = append(edges, supportmessage.EdgeTicket)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SupportMessageMutation) EdgeCleared(name string) bool {
	switch name {
	case supportmessage.EdgeTicket:
		return m.clearedticket
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SupportMessageMutation) ClearEdge(name string) error {
	switch name {
	case supportmessage.EdgeTicket:
		m.ClearTicket()
		return nil
	}
	return fmt.Errorf("unknown SupportMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SupportMessageMutation) ResetEdge(name string) error {
	switch name {
	case supportmessage.EdgeTicket:
		m.ResetTicket()
		return nil
	}
	return fmt.Errorf("unknown SupportMessage edge %s", name)
}

// SupportTicketMutation represents an operation that mutates the SupportTicket nodes in the graph.
type SupportTicketMutation struct {
	config
	op              Op
	typ             string
	id              *string
	email           *string
	subject         *string
	status          *supportticket.Status
	priority        *supportticket.Priority
	ai_response     *string
	human_response  *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	team            *string
	clearedteam     bool
	messages        map[string]struct{}
	removedmessages map[string]struct{}
	clearedmessages bool
	done            bool
	oldValue        func(context.Context) (*SupportTicket, error)
	predicates      []predicate.SupportTicket
}

var _ ent.Mutation = (*SupportTicketMutation)(nil)

// supportticketOption allows management of the mutation configuration using functional options.
type supportticketOption func(*SupportTicketMutation)

// newSupportTicketMutation creates new mutation for the SupportTicket entity.
func newSupportTicketMutation(c config, op Op, opts ...supportticketOption) *SupportTicketMutation {
	m := &SupportTicketMutation{
		config:        c,
		op:            op,
		typ:           TypeSupportTicket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSupportTicketID sets the ID field of the mutation.
func withSupportTicketID(id string) supportticketOption {
	return func(m *SupportTicketMutation) {
		var (
			err   error
			once  sync.Once
			value *SupportTicket
		)
		m.oldValue = func(ctx context.Context) (*SupportTicket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SupportTicket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSupportTicket sets the old SupportTicket of the mutation.
func withSupportTicket(node *SupportTicket) supportticketOption {
	return func(m *SupportTicketMutation) {
		m.oldValue = func(context.Context) (*SupportTicket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SupportTicketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SupportTicketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SupportTicket entities.
func (m *SupportTicketMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SupportTicketMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SupportTicketMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SupportTicket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *SupportTicketMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *SupportTicketMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the SupportTicket entity.
// If the SupportTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupportTicketMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *SupportTicketMutation) ResetEmail() {
	m.email = nil
}

// SetSubject sets the "subject" field.
func (m *SupportTicketMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *SupportTicketMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the SupportTicket entity.
// If the SupportTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupportTicketMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *SupportTicketMutation) ResetSubject() {
	m.subject = nil
}

// SetStatus sets the "status" field.
func (m *SupportTicketMutation) SetStatus(s supportticket.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SupportTicketMutation) Status() (r supportticket.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SupportTicket entity.
// If the SupportTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupportTicketMutation) OldStatus(ctx context.Context) (v supportticket.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SupportTicketMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *SupportTicketMutation) SetPriority(s supportticket.Priority) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *SupportTicketMutation) Priority() (r supportticket.Priority, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the SupportTicket entity.
// If the SupportTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupportTicketMutation) OldPriority(ctx context.Context) (v supportticket.Priority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *SupportTicketMutation) ResetPriority() {
	m.priority = nil
}

// SetAiResponse sets the "ai_response" field.
func (m *SupportTicketMutation) SetAiResponse(s string) {
	m.ai_response = &s
}

// AiResponse returns the value of the "ai_response" field in the mutation.
func (m *SupportTicketMutation) AiResponse() (r string, exists bool) {
	v := m.ai_response
	if v == nil {
		return
	}
	return *v, true
}

// OldAiResponse returns the old "ai_response" field's value of the SupportTicket entity.
// If the SupportTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupportTicketMutation) OldAiResponse(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAiResponse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAiResponse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAiResponse: %w", err)
	}
	return oldValue.AiResponse, nil
}

// ClearAiResponse clears the value of the "ai_response" field.
func (m *SupportTicketMutation) ClearAiResponse() {
	m.ai_response = nil
	m.clearedFields[supportticket.FieldAiResponse] = struct{}{}
}

// AiResponseCleared returns if the "ai_response" field was cleared in this mutation.
func (m *SupportTicketMutation) AiResponseCleared() bool {
	_, ok := m.clearedFields[supportticket.FieldAiResponse]
	return ok
}

// ResetAiResponse resets all changes to the "ai_response" field.
func (m *SupportTicketMutation) ResetAiResponse() {
	m.ai_response = nil
	delete(m.clearedFields, supportticket.FieldAiResponse)
}

// SetHumanResponse sets the "human_response" field.
func (m *SupportTicketMutation) SetHumanResponse(s string) {
	m.human_response = &s
}

// HumanResponse returns the value of the "human_response" field in the mutation.
func (m *SupportTicketMutation) HumanResponse() (r string, exists bool) {
	v := m.human_response
	if v == nil {
		return
	}
	return *v, true
}

// OldHumanResponse returns the old "human_response" field's value of the SupportTicket entity.
// If the SupportTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupportTicketMutation) OldHumanResponse(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHumanResponse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHumanResponse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHumanResponse: %w", err)
	}
	return oldValue.HumanResponse, nil
}

// ClearHumanResponse clears the value of the "human_response" field.
func (m *SupportTicketMutation) ClearHumanResponse() {
	m.human_response = nil
	m.clearedFields[supportticket.FieldHumanResponse] = struct{}{}
}

// HumanResponseCleared returns if the "human_response" field was cleared in this mutation.
func (m *SupportTicketMutation) HumanResponseCleared() bool {
	_, ok := m.clearedFields[supportticket.FieldHumanResponse]
	return ok
}

// ResetHumanResponse resets all changes to the "human_response" field.
func (m *SupportTicketMutation) ResetHumanResponse() {
	m.human_response = nil
	delete(m.clearedFields, supportticket.FieldHumanResponse)
}

// SetCreatedAt sets the "created_at" field.
func (m *SupportTicketMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SupportTicketMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SupportTicket entity.
// If the SupportTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupportTicketMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SupportTicketMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SupportTicketMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SupportTicketMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SupportTicket entity.
// If the SupportTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupportTicketMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SupportTicketMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *SupportTicketMutation) SetTeamID(id string) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *SupportTicketMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *SupportTicketMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *SupportTicketMutation) TeamID() (id string, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *SupportTicketMutation) TeamIDs() (ids []string) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *SupportTicketMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// AddMessageIDs adds the "messages" edge to the SupportMessage entity by ids.
func (m *SupportTicketMutation) AddMessageIDs(ids ...string) {
	if m.messages == nil {
		m.messages = make(map[string]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the SupportMessage entity.
func (m *SupportTicketMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the SupportMessage entity was cleared.
func (m *SupportTicketMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the SupportMessage entity by IDs.
func (m *SupportTicketMutation) RemoveMessageIDs(ids ...string) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the SupportMessage entity.
func (m *SupportTicketMutation) RemovedMessagesIDs() (ids []string) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *SupportTicketMutation) MessagesIDs() (ids []string) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *SupportTicketMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// Where appends a list predicates to the SupportTicketMutation builder.
func (m *SupportTicketMutation) Where(ps ...predicate.SupportTicket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SupportTicketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SupportTicketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SupportTicket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SupportTicketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SupportTicketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SupportTicket).
func (m *SupportTicketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SupportTicketMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.email != nil {
		fields = append(fields, supportticket.FieldEmail)
	}
	if m.subject != nil {
		fields = append(fields, supportticket.FieldSubject)
	}
	if m.status != nil {
		fields = append(fields, supportticket.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, supportticket.FieldPriority)
	}
	if m.ai_response != nil {
		fields = append(fields, supportticket.FieldAiResponse)
	}
	if m.human_response != nil {
		fields = append(fields, supportticket.FieldHumanResponse)
	}
	if m.created_at != nil {
		fields = append(fields, supportticket.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, supportticket.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SupportTicketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case supportticket.FieldEmail:
		return m.Email()
	case supportticket.FieldSubject:
		return m.Subject()
	case supportticket.FieldStatus:
		return m.Status()
	case supportticket.FieldPriority:
		return m.Priority()
	case supportticket.FieldAiResponse:
		return m.AiResponse()
	case supportticket.FieldHumanResponse:
		return m.HumanResponse()
	case supportticket.FieldCreatedAt:
		return m.CreatedAt()
	case supportticket.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SupportTicketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case supportticket.FieldEmail:
		return m.OldEmail(ctx)
	case supportticket.FieldSubject:
		return m.OldSubject(ctx)
	case supportticket.FieldStatus:
		return m.OldStatus(ctx)
	case supportticket.FieldPriority:
		return m.OldPriority(ctx)
	case supportticket.FieldAiResponse:
		return m.OldAiResponse(ctx)
	case supportticket.FieldHumanResponse:
		return m.OldHumanResponse(ctx)
	case supportticket.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case supportticket.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SupportTicket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupportTicketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case supportticket.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case supportticket.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case supportticket.FieldStatus:
		v, ok := value.(supportticket.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case supportticket.FieldPriority:
		v, ok := value.(supportticket.Priority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case supportticket.FieldAiResponse:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAiResponse(v)
		return nil
	case supportticket.FieldHumanResponse:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHumanResponse(v)
		return nil
	case supportticket.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case supportticket.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SupportTicket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SupportTicketMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SupportTicketMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupportTicketMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SupportTicket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SupportTicketMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(supportticket.FieldAiResponse) {
		fields = append(fields, supportticket.FieldAiResponse)
	}
	if m.FieldCleared(supportticket.FieldHumanResponse) {
		fields = append(fields, supportticket.FieldHumanResponse)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SupportTicketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SupportTicketMutation) ClearField(name string) error {
	switch name {
	case supportticket.FieldAiResponse:
		m.ClearAiResponse()
		return nil
	case supportticket.FieldHumanResponse:
		m.ClearHumanResponse()
		return nil
	}
	return fmt.Errorf("unknown SupportTicket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SupportTicketMutation) ResetField(name string) error {
	switch name {
	case supportticket.FieldEmail:
		m.ResetEmail()
		return nil
	case supportticket.FieldSubject:
		m.ResetSubject()
		return nil
	case supportticket.FieldStatus:
		m.ResetStatus()
		return nil
	case supportticket.FieldPriority:
		m.ResetPriority()
		return nil
	case supportticket.FieldAiResponse:
		m.ResetAiResponse()
		return nil
	case supportticket.FieldHumanResponse:
		m.ResetHumanResponse()
		return nil
	case supportticket.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case supportticket.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SupportTicket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SupportTicketMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.team != nil {
		edges = append(edges, supportticket.EdgeTeam)
	}
	if m.messages != nil {
		edges = append(edges, supportticket.EdgeMessages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SupportTicketMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case supportticket.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case supportticket.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SupportTicketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmessages != nil {
		edges = append(edges, supportticket.EdgeMessages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SupportTicketMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case supportticket.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SupportTicketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedteam {
		edges = append(edges, supportticket.EdgeTeam)
	}
	if m.clearedmessages {
		edges = append(edges, supportticket.EdgeMessages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SupportTicketMutation) EdgeCleared(name string) bool {
	switch name {
	case supportticket.EdgeTeam:
		return m.clearedteam
	case supportticket.EdgeMessages:
		return m.clearedmessages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SupportTicketMutation) ClearEdge(name string) error {
	switch name {
	case supportticket.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown SupportTicket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SupportTicketMutation) ResetEdge(name string) error {
	switch name {
	case supportticket.EdgeTeam:
		m.ResetTeam()
		return nil
	case supportticket.EdgeMessages:
		m.ResetMessages()
		return nil
	}
	return fmt.Errorf("unknown SupportTicket edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	name                     *string
	email                    *string
	plan                     *team.Plan
	status                   *team.Status
	stripe_customer_id       *string
	stripe_subscription_id   *string
	billing_interval         *team.BillingInterval
	current_period_end       *time.Time
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	watch_conditions         map[string]struct{}
	removedwatch_conditions  map[string]struct{}
	clearedwatch_conditions  bool
	notifications            map[string]struct{}
	removednotifications     map[string]struct{}
	clearednotifications     bool
	auth_tokens              map[string]struct{}
	removedauth_tokens       map[string]struct{}
	clearedauth_tokens       bool
	support_tickets          map[string]struct{}
	removedsupport_tickets   map[string]struct{}
	clearedsupport_tickets   bool
	promo_code_usages        map[string]struct{}
	removedpromo_code_usages map[string]struct{}
	clearedpromo_code_usages bool
	done                     bool
	oldValue                 func(context.Context) (*Team, error)
	predicates               []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id string) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *TeamMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *TeamMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *TeamMutation) ResetEmail() {
	m.email = nil
}

// SetPlan sets the "plan" field.
func (m *TeamMutation) SetPlan(t team.Plan) {
	m.plan = &t
}

// Plan returns the value of the "plan" field in the mutation.
func (m *TeamMutation) Plan() (r team.Plan, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlan returns the old "plan" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldPlan(ctx context.Context) (v team.Plan, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlan: %w", err)
	}
	return oldValue.Plan, nil
}

// ResetPlan resets all changes to the "plan" field.
func (m *TeamMutation) ResetPlan() {
	m.plan = nil
}

// SetStatus sets the "status" field.
func (m *TeamMutation) SetStatus(t team.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TeamMutation) Status() (r team.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldStatus(ctx context.Context) (v team.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TeamMutation) ResetStatus() {
	m.status = nil
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (m *TeamMutation) SetStripeCustomerID(s string) {
	m.stripe_customer_id = &s
}

// StripeCustomerID returns the value of the "stripe_customer_id" field in the mutation.
func (m *TeamMutation) StripeCustomerID() (r string, exists bool) {
	v := m.stripe_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeCustomerID returns the old "stripe_customer_id" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldStripeCustomerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeCustomerID: %w", err)
	}
	return oldValue.StripeCustomerID, nil
}

// ClearStripeCustomerID clears the value of the "stripe_customer_id" field.
func (m *TeamMutation) ClearStripeCustomerID() {
	m.stripe_customer_id = nil
	m.clearedFields[team.FieldStripeCustomerID] = struct{}{}
}

// StripeCustomerIDCleared returns if the "stripe_customer_id" field was cleared in this mutation.
func (m *TeamMutation) StripeCustomerIDCleared() bool {
	_, ok := m.clearedFields[team.FieldStripeCustomerID]
	return ok
}

// ResetStripeCustomerID resets all changes to the "stripe_customer_id" field.
func (m *TeamMutation) ResetStripeCustomerID() {
	m.stripe_customer_id = nil
	delete(m.clearedFields, team.FieldStripeCustomerID)
}

// SetStripeSubscriptionID sets the "stripe_subscription_id" field.
func (m *TeamMutation) SetStripeSubscriptionID(s string) {
	m.stripe_subscription_id = &s
}

// StripeSubscriptionID returns the value of the "stripe_subscription_id" field in the mutation.
func (m *TeamMutation) StripeSubscriptionID() (r string, exists bool) {
	v := m.stripe_subscription_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeSubscriptionID returns the old "stripe_subscription_id" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldStripeSubscriptionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeSubscriptionID: %w", err)
	}
	return oldValue.StripeSubscriptionID, nil
}

// ClearStripeSubscriptionID clears the value of the "stripe_subscription_id" field.
func (m *TeamMutation) ClearStripeSubscriptionID() {
	m.stripe_subscription_id = nil
	m.clearedFields[team.FieldStripeSubscriptionID] = struct{}{}
}

// StripeSubscriptionIDCleared returns if the "stripe_subscription_id" field was cleared in this mutation.
func (m *TeamMutation) StripeSubscriptionIDCleared() bool {
	_, ok := m.clearedFields[team.FieldStripeSubscriptionID]
	return ok
}

// ResetStripeSubscriptionID resets all changes to the "stripe_subscription_id" field.
func (m *TeamMutation) ResetStripeSubscriptionID() {
	m.stripe_subscription_id = nil
	delete(m.clearedFields, team.FieldStripeSubscriptionID)
}

// SetBillingInterval sets the "billing_interval" field.
func (m *TeamMutation) SetBillingInterval(ti team.BillingInterval) {
	m.billing_interval = &ti
}

// BillingInterval returns the value of the "billing_interval" field in the mutation.
func (m *TeamMutation) BillingInterval() (r team.BillingInterval, exists bool) {
	v := m.billing_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingInterval returns the old "billing_interval" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldBillingInterval(ctx context.Context) (v team.BillingInterval, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingInterval: %w", err)
	}
	return oldValue.BillingInterval, nil
}

// ClearBillingInterval clears the value of the "billing_interval" field.
func (m *TeamMutation) ClearBillingInterval() {
	m.billing_interval = nil
	m.clearedFields[team.FieldBillingInterval] = struct{}{}
}

// BillingIntervalCleared returns if the "billing_interval" field was cleared in this mutation.
func (m *TeamMutation) BillingIntervalCleared() bool {
	_, ok := m.clearedFields[team.FieldBillingInterval]
	return ok
}

// ResetBillingInterval resets all changes to the "billing_interval" field.
func (m *TeamMutation) ResetBillingInterval() {
	m.billing_interval = nil
	delete(m.clearedFields, team.FieldBillingInterval)
}

// SetCurrentPeriodEnd sets the "current_period_end" field.
func (m *TeamMutation) SetCurrentPeriodEnd(t time.Time) {
	m.current_period_end = &t
}

// CurrentPeriodEnd returns the value of the "current_period_end" field in the mutation.
func (m *TeamMutation) CurrentPeriodEnd() (r time.Time, exists bool) {
	v := m.current_period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentPeriodEnd returns the old "current_period_end" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCurrentPeriodEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentPeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentPeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentPeriodEnd: %w", err)
	}
	return oldValue.CurrentPeriodEnd, nil
}

// ClearCurrentPeriodEnd clears the value of the "current_period_end" field.
func (m *TeamMutation) ClearCurrentPeriodEnd() {
	m.current_period_end = nil
	m.clearedFields[team.FieldCurrentPeriodEnd] = struct{}{}
}

// CurrentPeriodEndCleared returns if the "current_period_end" field was cleared in this mutation.
func (m *TeamMutation) CurrentPeriodEndCleared() bool {
	_, ok := m.clearedFields[team.FieldCurrentPeriodEnd]
	return ok
}

// ResetCurrentPeriodEnd resets all changes to the "current_period_end" field.
func (m *TeamMutation) ResetCurrentPeriodEnd() {
	m.current_period_end = nil
	delete(m.clearedFields, team.FieldCurrentPeriodEnd)
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeamMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddWatchConditionIDs adds the "watch_conditions" edge to the WatchCondition entity by ids.
func (m *TeamMutation) AddWatchConditionIDs(ids ...string) {
	if m.watch_conditions == nil {
		m.watch_conditions = make(map[string]struct{})
	}
	for i := range ids {
		m.watch_conditions[ids[i]] = struct{}{}
	}
}

// ClearWatchConditions clears the "watch_conditions" edge to the WatchCondition entity.
func (m *TeamMutation) ClearWatchConditions() {
	m.clearedwatch_conditions = true
}

// WatchConditionsCleared reports if the "watch_conditions" edge to the WatchCondition entity was cleared.
func (m *TeamMutation) WatchConditionsCleared() bool {
	return m.clearedwatch_conditions
}

// RemoveWatchConditionIDs removes the "watch_conditions" edge to the WatchCondition entity by IDs.
func (m *TeamMutation) RemoveWatchConditionIDs(ids ...string) {
	if m.removedwatch_conditions == nil {
		m.removedwatch_conditions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.watch_conditions, ids[i])
		m.removedwatch_conditions[ids[i]] = struct{}{}
	}
}

// RemovedWatchConditions returns the removed IDs of the "watch_conditions" edge to the WatchCondition entity.
func (m *TeamMutation) RemovedWatchConditionsIDs() (ids []string) {
	for id := range m.removedwatch_conditions {
		ids = append(ids, id)
	}
	return
}

// WatchConditionsIDs returns the "watch_conditions" edge IDs in the mutation.
func (m *TeamMutation) WatchConditionsIDs() (ids []string) {
	for id := range m.watch_conditions {
		ids = append(ids, id)
	}
	return
}

// ResetWatchConditions resets all changes to the "watch_conditions" edge.
func (m *TeamMutation) ResetWatchConditions() {
	m.watch_conditions = nil
	m.clearedwatch_conditions = false
	m.removedwatch_conditions = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *TeamMutation) AddNotificationIDs(ids ...string) {
	if m.notifications == nil {
		m.notifications = make(map[string]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *TeamMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *TeamMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *TeamMutation) RemoveNotificationIDs(ids ...string) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *TeamMutation) RemovedNotificationsIDs() (ids []string) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *TeamMutation) NotificationsIDs() (ids []string) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *TeamMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// AddAuthTokenIDs adds the "auth_tokens" edge to the AuthToken entity by ids.
func (m *TeamMutation) AddAuthTokenIDs(ids ...string) {
	if m.auth_tokens == nil {
		m.auth_tokens = make(map[string]struct{})
	}
	for i := range ids {
		m.auth_tokens[ids[i]] = struct{}{}
	}
}

// ClearAuthTokens clears the "auth_tokens" edge to the AuthToken entity.
func (m *TeamMutation) ClearAuthTokens() {
	m.clearedauth_tokens = true
}

// AuthTokensCleared reports if the "auth_tokens" edge to the AuthToken entity was cleared.
func (m *TeamMutation) AuthTokensCleared() bool {
	return m.clearedauth_tokens
}

// RemoveAuthTokenIDs removes the "auth_tokens" edge to the AuthToken entity by IDs.
func (m *TeamMutation) RemoveAuthTokenIDs(ids ...string) {
	if m.removedauth_tokens == nil {
		m.removedauth_tokens = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.auth_tokens, ids[i])
		m.removedauth_tokens[ids[i]] = struct{}{}
	}
}

// RemovedAuthTokens returns the removed IDs of the "auth_tokens" edge to the AuthToken entity.
func (m *TeamMutation) RemovedAuthTokensIDs() (ids []string) {
	for id := range m.removedauth_tokens {
		ids = append(ids, id)
	}
	return
}

// AuthTokensIDs returns the "auth_tokens" edge IDs in the mutation.
func (m *TeamMutation) AuthTokensIDs() (ids []string) {
	for id := range m.auth_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetAuthTokens resets all changes to the "auth_tokens" edge.
func (m *TeamMutation) ResetAuthTokens() {
	m.auth_tokens = nil
	m.clearedauth_tokens = false
	m.removedauth_tokens = nil
}

// AddSupportTicketIDs adds the "support_tickets" edge to the SupportTicket entity by ids.
func (m *TeamMutation) AddSupportTicketIDs(ids ...string) {
	if m.support_tickets == nil {
		m.support_tickets = make(map[string]struct{})
	}
	for i := range ids {
		m.support_tickets[ids[i]] = struct{}{}
	}
}

// ClearSupportTickets clears the "support_tickets" edge to the SupportTicket entity.
func (m *TeamMutation) ClearSupportTickets() {
	m.clearedsupport_tickets = true
}

// SupportTicketsCleared reports if the "support_tickets" edge to the SupportTicket entity was cleared.
func (m *TeamMutation) SupportTicketsCleared() bool {
	return m.clearedsupport_tickets
}

// RemoveSupportTicketIDs removes the "support_tickets" edge to the SupportTicket entity by IDs.
func (m *TeamMutation) RemoveSupportTicketIDs(ids ...string) {
	if m.removedsupport_tickets == nil {
		m.removedsupport_tickets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.support_tickets, ids[i])
		m.removedsupport_tickets[ids[i]] = struct{}{}
	}
}

// RemovedSupportTickets returns the removed IDs of the "support_tickets" edge to the SupportTicket entity.
func (m *TeamMutation) RemovedSupportTicketsIDs() (ids []string) {
	for id := range m.removedsupport_tickets {
		ids = append(ids, id)
	}
	return
}

// SupportTicketsIDs returns the "support_tickets" edge IDs in the mutation.
func (m *TeamMutation) SupportTicketsIDs() (ids []string) {
	for id := range m.support_tickets {
		ids = append(ids, id)
	}
	return
}

// ResetSupportTickets resets all changes to the "support_tickets" edge.
func (m *TeamMutation) ResetSupportTickets() {
	m.support_tickets = nil
	m.clearedsupport_tickets = false
	m.removedsupport_tickets = nil
}

// AddPromoCodeUsageIDs adds the "promo_code_usages" edge to the PromoCodeUsage entity by ids.
func (m *TeamMutation) AddPromoCodeUsageIDs(ids ...string) {
	if m.promo_code_usages == nil {
		m.promo_code_usages = make(map[string]struct{})
	}
	for i := range ids {
		m.promo_code_usages[ids[i]] = struct{}{}
	}
}

// ClearPromoCodeUsages clears the "promo_code_usages" edge to the PromoCodeUsage entity.
func (m *TeamMutation) ClearPromoCodeUsages() {
	m.clearedpromo_code_usages = true
}

// PromoCodeUsagesCleared reports if the "promo_code_usages" edge to the PromoCodeUsage entity was cleared.
func (m *TeamMutation) PromoCodeUsagesCleared() bool {
	return m.clearedpromo_code_usages
}

// RemovePromoCodeUsageIDs removes the "promo_code_usages" edge to the PromoCodeUsage entity by IDs.
func (m *TeamMutation) RemovePromoCodeUsageIDs(ids ...string) {
	if m.removedpromo_code_usages == nil {
		m.removedpromo_code_usages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.promo_code_usages, ids[i])
		m.removedpromo_code_usages[ids[i]] = struct{}{}
	}
}

// RemovedPromoCodeUsages returns the removed IDs of the "promo_code_usages" edge to the PromoCodeUsage entity.
func (m *TeamMutation) RemovedPromoCodeUsagesIDs() (ids []string) {
	for id := range m.removedpromo_code_usages {
		ids = append(ids, id)
	}
	return
}

// PromoCodeUsagesIDs returns the "promo_code_usages" edge IDs in the mutation.
func (m *TeamMutation) PromoCodeUsagesIDs() (ids []string) {
	for id := range m.promo_code_usages {
		ids = append(ids, id)
	}
	return
}

// ResetPromoCodeUsages resets all changes to the "promo_code_usages" edge.
func (m *TeamMutation) ResetPromoCodeUsages() {
	m.promo_code_usages = nil
	m.clearedpromo_code_usages = false
	m.removedpromo_code_usages = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	if m.email != nil {
		fields = append(fields, team.FieldEmail)
	}
	if m.plan != nil {
		fields = append(fields, team.FieldPlan)
	}
	if m.status != nil {
		fields = append(fields, team.FieldStatus)
	}
	if m.stripe_customer_id != nil {
		fields = append(fields, team.FieldStripeCustomerID)
	}
	if m.stripe_subscription_id != nil {
		fields = append(fields, team.FieldStripeSubscriptionID)
	}
	if m.billing_interval != nil {
		fields = append(fields, team.FieldBillingInterval)
	}
	if m.current_period_end != nil {
		fields = append(fields, team.FieldCurrentPeriodEnd)
	}
	if m.created_at != nil {
		fields = append(fields, team.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, team.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldName:
		return m.Name()
	case team.FieldEmail:
		return m.Email()
	case team.FieldPlan:
		return m.Plan()
	case team.FieldStatus:
		return m.Status()
	case team.FieldStripeCustomerID:
		return m.StripeCustomerID()
	case team.FieldStripeSubscriptionID:
		return m.StripeSubscriptionID()
	case team.FieldBillingInterval:
		return m.BillingInterval()
	case team.FieldCurrentPeriodEnd:
		return m.CurrentPeriodEnd()
	case team.FieldCreatedAt:
		return m.CreatedAt()
	case team.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldName:
		return m.OldName(ctx)
	case team.FieldEmail:
		return m.OldEmail(ctx)
	case team.FieldPlan:
		return m.OldPlan(ctx)
	case team.FieldStatus:
		return m.OldStatus(ctx)
	case team.FieldStripeCustomerID:
		return m.OldStripeCustomerID(ctx)
	case team.FieldStripeSubscriptionID:
		return m.OldStripeSubscriptionID(ctx)
	case team.FieldBillingInterval:
		return m.OldBillingInterval(ctx)
	case team.FieldCurrentPeriodEnd:
		return m.OldCurrentPeriodEnd(ctx)
	case team.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case team.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case team.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case team.FieldPlan:
		v, ok := value.(team.Plan)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlan(v)
		return nil
	case team.FieldStatus:
		v, ok := value.(team.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case team.FieldStripeCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeCustomerID(v)
		return nil
	case team.FieldStripeSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeSubscriptionID(v)
		return nil
	case team.FieldBillingInterval:
		v, ok := value.(team.BillingInterval)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingInterval(v)
		return nil
	case team.FieldCurrentPeriodEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentPeriodEnd(v)
		return nil
	case team.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case team.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(team.FieldStripeCustomerID) {
		fields = append(fields, team.FieldStripeCustomerID)
	}
	if m.FieldCleared(team.FieldStripeSubscriptionID) {
		fields = append(fields, team.FieldStripeSubscriptionID)
	}
	if m.FieldCleared(team.FieldBillingInterval) {
		fields = append(fields, team.FieldBillingInterval)
	}
	if m.FieldCleared(team.FieldCurrentPeriodEnd) {
		fields = append(fields, team.FieldCurrentPeriodEnd)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	switch name {
	case team.FieldStripeCustomerID:
		m.ClearStripeCustomerID()
		return nil
	case team.FieldStripeSubscriptionID:
		m.ClearStripeSubscriptionID()
		return nil
	case team.FieldBillingInterval:
		m.ClearBillingInterval()
		return nil
	case team.FieldCurrentPeriodEnd:
		m.ClearCurrentPeriodEnd()
		return nil
	}
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldName:
		m.ResetName()
		return nil
	case team.FieldEmail:
		m.ResetEmail()
		return nil
	case team.FieldPlan:
		m.ResetPlan()
		return nil
	case team.FieldStatus:
		m.ResetStatus()
		return nil
	case team.FieldStripeCustomerID:
		m.ResetStripeCustomerID()
		return nil
	case team.FieldStripeSubscriptionID:
		m.ResetStripeSubscriptionID()
		return nil
	case team.FieldBillingInterval:
		m.ResetBillingInterval()
		return nil
	case team.FieldCurrentPeriodEnd:
		m.ResetCurrentPeriodEnd()
		return nil
	case team.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case team.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.watch_conditions != nil {
		edges = append(edges, team.EdgeWatchConditions)
	}
	if m.notifications != nil {
		edges = append(edges, team.EdgeNotifications)
	}
	if m.auth_tokens != nil {
		edges = append(edges, team.EdgeAuthTokens)
	}
	if m.support_tickets != nil {
		edges = append(edges, team.EdgeSupportTickets)
	}
	if m.promo_code_usages != nil {
		edges = append(edges, team.EdgePromoCodeUsages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeWatchConditions:
		ids := make([]ent.Value, 0, len(m.watch_conditions))
		for id := range m.watch_conditions {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeAuthTokens:
		ids := make([]ent.Value, 0, len(m.auth_tokens))
		for id := range m.auth_tokens {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeSupportTickets:
		ids := make([]ent.Value, 0, len(m.support_tickets))
		for id := range m.support_tickets {
			ids = append(ids, id)
		}
		return ids
	case team.EdgePromoCodeUsages:
		ids := make([]ent.Value, 0, len(m.promo_code_usages))
		for id := range m.promo_code_usages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedwatch_conditions != nil {
		edges = append(edges, team.EdgeWatchConditions)
	}
	if m.removednotifications != nil {
		edges = append(edges, team.EdgeNotifications)
	}
	if m.removedauth_tokens != nil {
		edges = append(edges, team.EdgeAuthTokens)
	}
	if m.removedsupport_tickets != nil {
		edges = append(edges, team.EdgeSupportTickets)
	}
	if m.removedpromo_code_usages != nil {
		edges = append(edges, team.EdgePromoCodeUsages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeWatchConditions:
		ids := make([]ent.Value, 0, len(m.removedwatch_conditions))
		for id := range m.removedwatch_conditions {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeAuthTokens:
		ids := make([]ent.Value, 0, len(m.removedauth_tokens))
		for id := range m.removedauth_tokens {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeSupportTickets:
		ids := make([]ent.Value, 0, len(m.removedsupport_tickets))
		for id := range m.removedsupport_tickets {
			ids = append(ids, id)
		}
		return ids
	case team.EdgePromoCodeUsages:
		ids := make([]ent.Value, 0, len(m.removedpromo_code_usages))
		for id := range m.removedpromo_code_usages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedwatch_conditions {
		edges = append(edges, team.EdgeWatchConditions)
	}
	if m.clearednotifications {
		edges = append(edges, team.EdgeNotifications)
	}
	if m.clearedauth_tokens {
		edges = append(edges, team.EdgeAuthTokens)
	}
	if m.clearedsupport_tickets {
		edges = append(edges, team.EdgeSupportTickets)
	}
	if m.clearedpromo_code_usages {
		edges = append(edges, team.EdgePromoCodeUsages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeWatchConditions:
		return m.clearedwatch_conditions
	case team.EdgeNotifications:
		return m.clearednotifications
	case team.EdgeAuthTokens:
		return m.clearedauth_tokens
	case team.EdgeSupportTickets:
		return m.clearedsupport_tickets
	case team.EdgePromoCodeUsages:
		return m.clearedpromo_code_usages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeWatchConditions:
		m.ResetWatchConditions()
		return nil
	case team.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case team.EdgeAuthTokens:
		m.ResetAuthTokens()
		return nil
	case team.EdgeSupportTickets:
		m.ResetSupportTickets()
		return nil
	case team.EdgePromoCodeUsages:
		m.ResetPromoCodeUsages()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// WatchConditionMutation represents an operation that mutates the WatchCondition nodes in the graph.
type WatchConditionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	days_of_week         *string
	time_from            *string
	time_to              *string
	date_from            *time.Time
	date_to              *time.Time
	enabled              *bool
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	team                 *string
	clearedteam          bool
	facility             *string
	clearedfacility      bool
	notifications        map[string]struct{}
	removednotifications map[string]struct{}
	clearednotifications bool
	done                 bool
	oldValue             func(context.Context) (*WatchCondition, error)
	predicates           []predicate.WatchCondition
}

var _ ent.Mutation = (*WatchConditionMutation)(nil)

// watchconditionOption allows management of the mutation configuration using functional options.
type watchconditionOption func(*WatchConditionMutation)

// newWatchConditionMutation creates new mutation for the WatchCondition entity.
func newWatchConditionMutation(c config, op Op, opts ...watchconditionOption) *WatchConditionMutation {
	m := &WatchConditionMutation{
		config:        c,
		op:            op,
		typ:           TypeWatchCondition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWatchConditionID sets the ID field of the mutation.
func withWatchConditionID(id string) watchconditionOption {
	return func(m *WatchConditionMutation) {
		var (
			err   error
			once  sync.Once
			value *WatchCondition
		)
		m.oldValue = func(ctx context.Context) (*WatchCondition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WatchCondition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWatchCondition sets the old WatchCondition of the mutation.
func withWatchCondition(node *WatchCondition) watchconditionOption {
	return func(m *WatchConditionMutation) {
		m.oldValue = func(context.Context) (*WatchCondition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WatchConditionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WatchConditionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WatchCondition entities.
func (m *WatchConditionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WatchConditionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WatchConditionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WatchCondition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDaysOfWeek sets the "days_of_week" field.
func (m *WatchConditionMutation) SetDaysOfWeek(s string) {
	m.days_of_week = &s
}

// DaysOfWeek returns the value of the "days_of_week" field in the mutation.
func (m *WatchConditionMutation) DaysOfWeek() (r string, exists bool) {
	v := m.days_of_week
	if v == nil {
		return
	}
	return *v, true
}

// OldDaysOfWeek returns the old "days_of_week" field's value of the WatchCondition entity.
// If the WatchCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchConditionMutation) OldDaysOfWeek(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDaysOfWeek is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDaysOfWeek requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDaysOfWeek: %w", err)
	}
	return oldValue.DaysOfWeek, nil
}

// ResetDaysOfWeek resets all changes to the "days_of_week" field.
func (m *WatchConditionMutation) ResetDaysOfWeek() {
	m.days_of_week = nil
}

// SetTimeFrom sets the "time_from" field.
func (m *WatchConditionMutation) SetTimeFrom(s string) {
	m.time_from = &s
}

// TimeFrom returns the value of the "time_from" field in the mutation.
func (m *WatchConditionMutation) TimeFrom() (r string, exists bool) {
	v := m.time_from
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeFrom returns the old "time_from" field's value of the WatchCondition entity.
// If the WatchCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchConditionMutation) OldTimeFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeFrom: %w", err)
	}
	return oldValue.TimeFrom, nil
}

// ResetTimeFrom resets all changes to the "time_from" field.
func (m *WatchConditionMutation) ResetTimeFrom() {
	m.time_from = nil
}

// SetTimeTo sets the "time_to" field.
func (m *WatchConditionMutation) SetTimeTo(s string) {
	m.time_to = &s
}

// TimeTo returns the value of the "time_to" field in the mutation.
func (m *WatchConditionMutation) TimeTo() (r string, exists bool) {
	v := m.time_to
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeTo returns the old "time_to" field's value of the WatchCondition entity.
// If the WatchCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchConditionMutation) OldTimeTo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeTo: %w", err)
	}
	return oldValue.TimeTo, nil
}

// ResetTimeTo resets all changes to the "time_to" field.
func (m *WatchConditionMutation) ResetTimeTo() {
	m.time_to = nil
}

// SetDateFrom sets the "date_from" field.
func (m *WatchConditionMutation) SetDateFrom(t time.Time) {
	m.date_from = &t
}

// DateFrom returns the value of the "date_from" field in the mutation.
func (m *WatchConditionMutation) DateFrom() (r time.Time, exists bool) {
	v := m.date_from
	if v == nil {
		return
	}
	return *v, true
}

// OldDateFrom returns the old "date_from" field's value of the WatchCondition entity.
// If the WatchCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchConditionMutation) OldDateFrom(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateFrom: %w", err)
	}
	return oldValue.DateFrom, nil
}

// ClearDateFrom clears the value of the "date_from" field.
func (m *WatchConditionMutation) ClearDateFrom() {
	m.date_from = nil
	m.clearedFields[watchcondition.FieldDateFrom] = struct{}{}
}

// DateFromCleared returns if the "date_from" field was cleared in this mutation.
func (m *WatchConditionMutation) DateFromCleared() bool {
	_, ok := m.clearedFields[watchcondition.FieldDateFrom]
	return ok
}

// ResetDateFrom resets all changes to the "date_from" field.
func (m *WatchConditionMutation) ResetDateFrom() {
	m.date_from = nil
	delete(m.clearedFields, watchcondition.FieldDateFrom)
}

// SetDateTo sets the "date_to" field.
func (m *WatchConditionMutation) SetDateTo(t time.Time) {
	m.date_to = &t
}

// DateTo returns the value of the "date_to" field in the mutation.
func (m *WatchConditionMutation) DateTo() (r time.Time, exists bool) {
	v := m.date_to
	if v == nil {
		return
	}
	return *v, true
}

// OldDateTo returns the old "date_to" field's value of the WatchCondition entity.
// If the WatchCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchConditionMutation) OldDateTo(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateTo: %w", err)
	}
	return oldValue.DateTo, nil
}

// ClearDateTo clears the value of the "date_to" field.
func (m *WatchConditionMutation) ClearDateTo() {
	m.date_to = nil
	m.clearedFields[watchcondition.FieldDateTo] = struct{}{}
}

// DateToCleared returns if the "date_to" field was cleared in this mutation.
func (m *WatchConditionMutation) DateToCleared() bool {
	_, ok := m.clearedFields[watchcondition.FieldDateTo]
	return ok
}

// ResetDateTo resets all changes to the "date_to" field.
func (m *WatchConditionMutation) ResetDateTo() {
	m.date_to = nil
	delete(m.clearedFields, watchcondition.FieldDateTo)
}

// SetEnabled sets the "enabled" field.
func (m *WatchConditionMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *WatchConditionMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the WatchCondition entity.
// If the WatchCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchConditionMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *WatchConditionMutation) ResetEnabled() {
	m.enabled = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WatchConditionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WatchConditionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WatchCondition entity.
// If the WatchCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchConditionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WatchConditionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WatchConditionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WatchConditionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WatchCondition entity.
// If the WatchCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchConditionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WatchConditionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *WatchConditionMutation) SetTeamID(id string) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *WatchConditionMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *WatchConditionMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *WatchConditionMutation) TeamID() (id string, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *WatchConditionMutation) TeamIDs() (ids []string) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *WatchConditionMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// SetFacilityID sets the "facility" edge to the Facility entity by id.
func (m *WatchConditionMutation) SetFacilityID(id string) {
	m.facility = &id
}

// ClearFacility clears the "facility" edge to the Facility entity.
func (m *WatchConditionMutation) ClearFacility() {
	m.clearedfacility = true
}

// FacilityCleared reports if the "facility" edge to the Facility entity was cleared.
func (m *WatchConditionMutation) FacilityCleared() bool {
	return m.clearedfacility
}

// FacilityID returns the "facility" edge ID in the mutation.
func (m *WatchConditionMutation) FacilityID() (id string, exists bool) {
	if m.facility != nil {
		return *m.facility, true
	}
	return
}

// FacilityIDs returns the "facility" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FacilityID instead. It exists only for internal usage by the builders.
func (m *WatchConditionMutation) FacilityIDs() (ids []string) {
	if id := m.facility; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFacility resets all changes to the "facility" edge.
func (m *WatchConditionMutation) ResetFacility() {
	m.facility = nil
	m.clearedfacility = false
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *WatchConditionMutation) AddNotificationIDs(ids ...string) {
	if m.notifications == nil {
		m.notifications = make(map[string]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *WatchConditionMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *WatchConditionMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *WatchConditionMutation) RemoveNotificationIDs(ids ...string) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *WatchConditionMutation) RemovedNotificationsIDs() (ids []string) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *WatchConditionMutation) NotificationsIDs() (ids []string) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *WatchConditionMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// Where appends a list predicates to the WatchConditionMutation builder.
func (m *WatchConditionMutation) Where(ps ...predicate.WatchCondition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WatchConditionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WatchConditionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WatchCondition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WatchConditionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WatchConditionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WatchCondition).
func (m *WatchConditionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WatchConditionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.days_of_week != nil {
		fields = append(fields, watchcondition.FieldDaysOfWeek)
	}
	if m.time_from != nil {
		fields = append(fields, watchcondition.FieldTimeFrom)
	}
	if m.time_to != nil {
		fields = append(fields, watchcondition.FieldTimeTo)
	}
	if m.date_from != nil {
		fields = append(fields, watchcondition.FieldDateFrom)
	}
	if m.date_to != nil {
		fields = append(fields, watchcondition.FieldDateTo)
	}
	if m.enabled != nil {
		fields = append(fields, watchcondition.FieldEnabled)
	}
	if m.created_at != nil {
		fields = append(fields, watchcondition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, watchcondition.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WatchConditionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case watchcondition.FieldDaysOfWeek:
		return m.DaysOfWeek()
	case watchcondition.FieldTimeFrom:
		return m.TimeFrom()
	case watchcondition.FieldTimeTo:
		return m.TimeTo()
	case watchcondition.FieldDateFrom:
		return m.DateFrom()
	case watchcondition.FieldDateTo:
		return m.DateTo()
	case watchcondition.FieldEnabled:
		return m.Enabled()
	case watchcondition.FieldCreatedAt:
		return m.CreatedAt()
	case watchcondition.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WatchConditionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case watchcondition.FieldDaysOfWeek:
		return m.OldDaysOfWeek(ctx)
	case watchcondition.FieldTimeFrom:
		return m.OldTimeFrom(ctx)
	case watchcondition.FieldTimeTo:
		return m.OldTimeTo(ctx)
	case watchcondition.FieldDateFrom:
		return m.OldDateFrom(ctx)
	case watchcondition.FieldDateTo:
		return m.OldDateTo(ctx)
	case watchcondition.FieldEnabled:
		return m.OldEnabled(ctx)
	case watchcondition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case watchcondition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WatchCondition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WatchConditionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case watchcondition.FieldDaysOfWeek:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDaysOfWeek(v)
		return nil
	case watchcondition.FieldTimeFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeFrom(v)
		return nil
	case watchcondition.FieldTimeTo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeTo(v)
		return nil
	case watchcondition.FieldDateFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateFrom(v)
		return nil
	case watchcondition.FieldDateTo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateTo(v)
		return nil
	case watchcondition.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case watchcondition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case watchcondition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WatchCondition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WatchConditionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WatchConditionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WatchConditionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WatchCondition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WatchConditionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(watchcondition.FieldDateFrom) {
		fields = append(fields, watchcondition.FieldDateFrom)
	}
	if m.FieldCleared(watchcondition.FieldDateTo) {
		fields = append(fields, watchcondition.FieldDateTo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WatchConditionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WatchConditionMutation) ClearField(name string) error {
	switch name {
	case watchcondition.FieldDateFrom:
		m.ClearDateFrom()
		return nil
	case watchcondition.FieldDateTo:
		m.ClearDateTo()
		return nil
	}
	return fmt.Errorf("unknown WatchCondition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WatchConditionMutation) ResetField(name string) error {
	switch name {
	case watchcondition.FieldDaysOfWeek:
		m.ResetDaysOfWeek()
		return nil
	case watchcondition.FieldTimeFrom:
		m.ResetTimeFrom()
		return nil
	case watchcondition.FieldTimeTo:
		m.ResetTimeTo()
		return nil
	case watchcondition.FieldDateFrom:
		m.ResetDateFrom()
		return nil
	case watchcondition.FieldDateTo:
		m.ResetDateTo()
		return nil
	case watchcondition.FieldEnabled:
		m.ResetEnabled()
		return nil
	case watchcondition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case watchcondition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WatchCondition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WatchConditionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.team != nil {
		edges = append(edges, watchcondition.EdgeTeam)
	}
	if m.facility != nil {
		edges = append(edges, watchcondition.EdgeFacility)
	}
	if m.notifications != nil {
		edges = append(edges, watchcondition.EdgeNotifications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WatchConditionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case watchcondition.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case watchcondition.EdgeFacility:
		if id := m.facility; id != nil {
			return []ent.Value{*id}
		}
	case watchcondition.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WatchConditionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removednotifications != nil {
		edges = append(edges, watchcondition.EdgeNotifications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WatchConditionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case watchcondition.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WatchConditionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedteam {
		edges = append(edges, watchcondition.EdgeTeam)
	}
	if m.clearedfacility {
		edges = append(edges, watchcondition.EdgeFacility)
	}
	if m.clearednotifications {
		edges = append(edges, watchcondition.EdgeNotifications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WatchConditionMutation) EdgeCleared(name string) bool {
	switch name {
	case watchcondition.EdgeTeam:
		return m.clearedteam
	case watchcondition.EdgeFacility:
		return m.clearedfacility
	case watchcondition.EdgeNotifications:
		return m.clearednotifications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WatchConditionMutation) ClearEdge(name string) error {
	switch name {
	case watchcondition.EdgeTeam:
		m.ClearTeam()
		return nil
	case watchcondition.EdgeFacility:
		m.ClearFacility()
		return nil
	}
	return fmt.Errorf("unknown WatchCondition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WatchConditionMutation) ResetEdge(name string) error {
	switch name {
	case watchcondition.EdgeTeam:
		m.ResetTeam()
		return nil
	case watchcondition.EdgeFacility:
		m.ResetFacility()
		return nil
	case watchcondition.EdgeNotifications:
		m.ResetNotifications()
		return nil
	}
	return fmt.Errorf("unknown WatchCondition edge %s", name)
}
